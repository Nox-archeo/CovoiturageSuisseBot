import os
import json
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    CommandHandler,
    CallbackContext,
    ConversationHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters
)
from database.models import Trip, User, Booking
from database import get_db
from utils.validators import validate_date, validate_price, validate_seats
from .trip_preferences import show_preferences_menu

# Configuration du logger
logger = logging.getLogger(__name__)

# Ã‰tats de conversation (IMPORTANT: dÃ©finir avant toute utilisation)
(
    CHOOSING_TYPE,
    CHOOSING_DEPARTURE,
    CHOOSING_DESTINATION,
    ENTERING_DEPARTURE,
    ENTERING_ARRIVAL,
    DATE,
    SEATS,
    PRICE,
    CONFIRM,
    TRIP_TYPE,
    DEPARTURE,
    ARRIVAL,
    ADDING_STOP,
    MEETING_POINT
) = range(14)

def load_cities():
    """Charge le fichier cities.json"""
    try:
        cities_file = os.path.join(
            os.path.dirname(os.path.dirname(__file__)), 
            'src', 'bot', 'data', 'cities.json'
        )
        with open(cities_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
            return [city['name'] for city in data['cities']]
    except Exception as e:
        logger.error(f"Erreur chargement cities.json: {e}")
        return [
            "ZÃ¼rich", "GenÃ¨ve", "BÃ¢le", "Lausanne", "Berne", 
            "Lucerne", "Fribourg", "NeuchÃ¢tel", "Sion"
        ]  # Liste par dÃ©faut

# Charger les villes au dÃ©marrage
SWISS_CITIES = load_cities()

async def create_trip(update: Update, context):
    """Processus de crÃ©ation de trajet amÃ©liorÃ©"""
    keyboard = [
        [
            InlineKeyboardButton("ğŸš— Trajet simple", callback_data="trip_oneway"),
            InlineKeyboardButton("ğŸ”„ Aller-retour", callback_data="trip_roundtrip")
        ],
        [
            InlineKeyboardButton("ğŸ‘© Entre femmes uniquement", callback_data="trip_women_only"),
            InlineKeyboardButton("âš¡ RÃ©servation instantanÃ©e", callback_data="trip_instant")
        ]
    ]
    
    await update.message.reply_text(
        "ğŸš— CrÃ©ation d'un nouveau trajet\n"
        "Choisissez le type de trajet:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return TRIP_TYPE

async def add_stops(update: Update, context):
    """Ajoute des arrÃªts intermÃ©diaires"""
    if 'stops' not in context.user_data:
        context.user_data['stops'] = []
    
    keyboard = [
        [InlineKeyboardButton("âœ… Terminer les arrÃªts", callback_data="stops_done")],
        [InlineKeyboardButton("âŒ Annuler", callback_data="stops_cancel")]
    ]
    
    await update.message.reply_text(
        f"ğŸš ArrÃªts actuels: {', '.join(context.user_data['stops']) if context.user_data['stops'] else 'Aucun'}\n"
        "Entrez un nouvel arrÃªt ou terminez:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return ADDING_STOP

async def handle_preferences(update: Update, context):
    """Gestion des prÃ©fÃ©rences du trajet"""
    keyboard = [
        [
            InlineKeyboardButton("ğŸš­ Non-fumeur", callback_data="pref_no_smoking"),
            InlineKeyboardButton("ğŸ”Š Musique", callback_data="pref_music")
        ],
        [
            InlineKeyboardButton("ğŸ± Animaux", callback_data="pref_pets"),
            InlineKeyboardButton("ğŸ’¼ Bagages", callback_data="pref_luggage")
        ],
        [
            InlineKeyboardButton("ğŸ‘© Entre femmes", callback_data="pref_women_only")
        ]
    ]
    await update.message.reply_text(
        "DÃ©finissez vos prÃ©fÃ©rences pour ce trajet:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def search_trip(update: Update, context: CallbackContext):
    """Commence la recherche de trajet"""
    # CrÃ©er un clavier avec les villes principales
    keyboard = []
    popular_cities = ["Fribourg", "GenÃ¨ve", "Lausanne", "ZÃ¼rich", "Berne", "BÃ¢le"]
    
    for city in popular_cities:
        keyboard.append([InlineKeyboardButton(city, callback_data=f"from_{city}")])
    
    keyboard.append([InlineKeyboardButton("ğŸ” Recherche avancÃ©e", callback_data="advanced_search")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "ğŸ” Recherche de trajets\n\n"
        "1ï¸âƒ£ Choisissez votre ville de dÃ©part:\n"
        "- SÃ©lectionnez une ville dans la liste\n"
        "- Ou utilisez la recherche avancÃ©e",
        reply_markup=reply_markup
    )
    return ENTERING_DEPARTURE

async def handle_departure(update: Update, context):
    """Traite la ville de dÃ©part"""
    try:
        if update.callback_query:
            query = update.callback_query
            await query.answer()
            if query.data == "other_city":
                await query.edit_message_text(
                    "ğŸ™ï¸ Entrez le nom de la ville ou le code postal:\n"
                    "Exemple: Bulle, 1630, Fribourg, etc."
                )
                return DEPARTURE
            city_info = query.data.replace("dep_", "").split('|')
            if len(city_info) == 2:
                context.user_data['departure'] = {
                    'name': city_info[0],
                    'zip': city_info[1]
                }
        else:
            user_input = update.message.text.strip()
            logger.info(f"Searching locality: {user_input}")
            
            matches = find_locality(user_input)
            logger.info(f"Found matches: {matches}")
            
            if matches:
                keyboard = []
                for match in matches:
                    display_text = format_locality_result(match)
                    callback_data = f"dep_{match['name']}|{match['zip']}"
                    keyboard.append([InlineKeyboardButton(display_text, callback_data=callback_data)])
                
                keyboard.append([InlineKeyboardButton("âŒ Annuler", callback_data="cancel_trip")])
                
                await update.message.reply_text(
                    "Choisissez une ville:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return DEPARTURE
            else:
                await update.message.reply_text(
                    "âŒ Ville non trouvÃ©e.\n"
                    "Veuillez entrer un nom de ville ou un code postal valide."
                )
                return DEPARTURE

        # Si on a une ville valide, passer Ã  l'Ã©tape suivante
        if 'departure' in context.user_data:
            departure = context.user_data['departure']
            keyboard = []
            for city in get_popular_destinations():
                if city['name'] != departure['name']:
                    display_text = format_locality_result(city)
                    callback_data = f"arr_{city['name']}|{city['zip']}"
                    keyboard.append([InlineKeyboardButton(display_text, callback_data=callback_data)])
            
            keyboard.append([InlineKeyboardButton("ğŸ” Autre ville", callback_data="other_arrival")])
            keyboard.append([InlineKeyboardButton("âŒ Annuler", callback_data="cancel_trip")])
            
            message_text = (
                f"DÃ©part depuis : {departure['name']} ({departure['zip']})\n\n"
                "Choisissez la ville d'arrivÃ©e :"
            )
            
            if update.callback_query:
                await update.callback_query.edit_message_text(
                    text=message_text,
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            else:
                await update.message.reply_text(
                    text=message_text,
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            return ARRIVAL

    except Exception as e:
        logger.error(f"Error in handle_departure: {str(e)}")
        if update.message:
            await update.message.reply_text(
                "Une erreur est survenue. Veuillez rÃ©essayer avec /creer"
            )
        return ConversationHandler.END

async def arrival(update: Update, context):
    """GÃ¨re la ville d'arrivÃ©e"""
    context.user_data['arrival'] = update.message.text
    await update.message.reply_text(
        "Ã€ quelle date et heure? (format: JJ/MM/AAAA HH:MM)"
    )
    return DATE

async def handle_arrival(update: Update, context):
    """Traite la ville d'arrivÃ©e"""
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        if query.data == "other_arrival":
            await query.edit_message_text(
                "ğŸ™ï¸ Entrez la ville d'arrivÃ©e:\n"
                "Par exemple: Bulle, Bienne, etc."
            )
            return ARRIVAL
        city_info = query.data.replace("arr_", "").split('|')
        if len(city_info) == 2:
            context.user_data['arrival'] = {
                'name': city_info[0],
                'zip': city_info[1]
            }
    else:
        # Recherche par nom ou NPA
        query_text = update.message.text.strip()
        matches = find_locality(query_text)
        
        if matches:
            keyboard = []
            for match in matches:
                display_text = format_locality_result(match)
                callback_data = f"arr_{match['name']}|{match['zip']}"
                keyboard.append([InlineKeyboardButton(display_text, callback_data=callback_data)])
            
            keyboard.append([InlineKeyboardButton("âŒ Annuler", callback_data="cancel_trip")])
            await update.message.reply_text(
                "SÃ©lectionnez la localitÃ© :",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return ARRIVAL
        else:
            await update.message.reply_text(
                "âŒ LocalitÃ© non trouvÃ©e.\n"
                "Veuillez entrer un nom de ville ou un code postal (NPA) valide."
            )
            return ARRIVAL

    # Si on a une ville d'arrivÃ©e valide, passer Ã  la date
    if 'arrival' in context.user_data:
        departure = context.user_data['departure']
        arrival = context.user_data['arrival']
        
        message_text = (
            "ğŸš— Nouveau trajet\n\n"
            f"De: {departure['name']} ({departure['zip']})\n"
            f"Ã€: {arrival['name']} ({arrival['zip']})\n\n"
            "ğŸ“… Entrez la date et l'heure du dÃ©part\n"
            "Format: JJ/MM/AAAA HH:MM\n"
            "Exemple: 25/04/2024 14:30"
        )
        
        if update.callback_query:
            await query.edit_message_text(text=message_text)
        else:
            await update.message.reply_text(text=message_text)
        return DATE

async def date(update: Update, context):
    """GÃ¨re la date et l'heure"""
    date_str = update.message.text
    if not validate_date(date_str):
        await update.message.reply_text("Format invalide. Utilisez JJ/MM/AAAA HH:MM")
        return DATE
    
    context.user_data['date'] = date_str
    await update.message.reply_text("Combien de places disponibles?")
    return SEATS

async def seats(update: Update, context):
    """GÃ¨re le nombre de places"""
    seats = update.message.text
    if not validate_seats(seats):
        await update.message.reply_text("Nombre de places invalide (1-8)")
        return SEATS
    
    context.user_data['seats'] = seats
    await update.message.reply_text("Quel est le prix par place (en CHF)?")
    return PRICE

async def price(update: Update, context):
    """GÃ¨re le prix"""
    price = update.message.text
    if not validate_price(price):
        await update.message.reply_text("Prix invalide (1-1000 CHF)")
        return PRICE
    
    context.user_data['price'] = price
    # Afficher le rÃ©sumÃ©
    keyboard = [[
        InlineKeyboardButton("Confirmer", callback_data="confirm_trip"),
        InlineKeyboardButton("Annuler", callback_data="cancel_trip")
    ]]
    await update.message.reply_text(
        "RÃ©sumÃ© du trajet:\n"
        f"De: {context.user_data['departure']}\n"
        f"Ã€: {context.user_data['arrival']}\n"
        f"Date: {context.user_data['date']}\n"
        f"Places: {context.user_data['seats']}\n"
        f"Prix: {context.user_data['price']} CHF\n\n"
        "Confirmez-vous ces informations?",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return CONFIRM

async def confirm(update: Update, context):
    """Confirme la crÃ©ation du trajet"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "confirm_trip":
        # Sauvegarder le trajet dans la base de donnÃ©es
        # ...
        await query.message.edit_text("Trajet crÃ©Ã© avec succÃ¨s! ğŸš—")
    else:
        await query.message.edit_text("CrÃ©ation du trajet annulÃ©e.")
    
    return ConversationHandler.END

async def cancel(update: Update, context):
    """Annule la crÃ©ation du trajet"""
    await update.message.reply_text("CrÃ©ation du trajet annulÃ©e.")
    return ConversationHandler.END

async def handle_departure(update: Update, context):
    """Traite la ville de dÃ©part"""
    query = update.callback_query
    
    if query and query.data == "advanced_search":
        await query.message.reply_text(
            "ğŸ“ Entrez le nom de votre ville de dÃ©part:\n"
            "Par exemple: Bulle, NeuchÃ¢tel, etc."
        )
        return ENTERING_DEPARTURE
    
    if query:
        city = query.data.replace("from_", "")
        context.user_data['departure'] = city
        await query.answer()  # Acquitter le callback
    else:
        city = update.message.text
        if city.lower() not in [c.lower() for c in SWISS_CITIES]:
            closest_matches = get_closest_matches(city, SWISS_CITIES)
            keyboard = [[InlineKeyboardButton(c, callback_data=f"from_{c}")] for c in closest_matches]
            await update.message.reply_text(
                "Ville non trouvÃ©e. Voulez-vous dire:\n",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return ENTERING_DEPARTURE
        context.user_data['departure'] = city

    # Afficher le choix de la destination
    keyboard = []
    for city in SWISS_CITIES[:6]:
        if city.lower() != context.user_data['departure'].lower():
            keyboard.append([InlineKeyboardButton(city, callback_data=f"to_{city}")])
    keyboard.append([InlineKeyboardButton("ğŸ” Autre destination", callback_data="other_destination")])
    
    await query.message.edit_text(
        f"DÃ©part: {context.user_data['departure']}\n\n"
        "2ï¸âƒ£ Choisissez votre destination:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return ENTERING_ARRIVAL

async def handle_arrival(update: Update, context):
    """Traite la ville d'arrivÃ©e"""
    query = update.callback_query
    if query:
        city = query.data.replace("to_", "")
        context.user_data['arrival'] = city
    else:
        city = update.message.text
        if city not in SWISS_CITIES:
            await update.message.reply_text(
                "Cette ville n'est pas dans notre liste. Veuillez choisir une ville suisse:"
            )
            return ENTERING_ARRIVAL
        context.user_data['arrival'] = city

    # Afficher les trajets disponibles
    await update.message.reply_text(
        f"Recherche des trajets de {context.user_data['departure']} Ã  {context.user_data['arrival']}...\n"
        "Cette fonctionnalitÃ© sera bientÃ´t disponible!"
    )
    return ConversationHandler.END

def get_closest_matches(city, cities_list, max_matches=3):
    """Trouve les villes les plus proches dans la liste"""
    # ImplÃ©mentation simple, Ã  amÃ©liorer avec fuzzy matching
    return [c for c in cities_list if city.lower() in c.lower()][:max_matches]

async def list_my_trips(update: Update, context):
    """Affiche la liste des trajets de l'utilisateur"""
    user_id = update.effective_user.id
    db = get_db()
    
    # RÃ©cupÃ©rer les trajets oÃ¹ l'utilisateur est conducteur
    driver_trips = db.query(Trip).join(User).filter(User.telegram_id == user_id).all()
    
    # RÃ©cupÃ©rer les rÃ©servations de l'utilisateur
    passenger_bookings = db.query(Booking).join(User).filter(User.telegram_id == user_id).all()
    
    message = "ğŸš— Vos trajets:\n\n"
    
    if driver_trips:
        message += "En tant que conducteur:\n"
        for trip in driver_trips:
            message += f"â€¢ {trip.departure_city} â†’ {trip.arrival_city} le {trip.departure_time}\n"
    
    if passenger_bookings:
        message += "\nEn tant que passager:\n"
        for booking in passenger_bookings:
            message += f"â€¢ {booking.trip.departure_city} â†’ {booking.trip.arrival_city} le {booking.trip.departure_time}\n"
    
    if not driver_trips and not passenger_bookings:
        message = "Vous n'avez pas encore de trajets."
    
    keyboard = [
        [
            InlineKeyboardButton("ğŸš— CrÃ©er un trajet", callback_data="create_trip"),
            InlineKeyboardButton("ğŸ” Chercher un trajet", callback_data="search_trip")
        ]
    ]
    
    await update.message.reply_text(
        message,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def handle_trip_type(update: Update, context):
    """GÃ¨re le choix du type de trajet"""
    query = update.callback_query
    if query:
        await query.answer()  # Important: toujours rÃ©pondre au callback
        
        choice = query.data.replace("trip_", "")
        context.user_data['trip_type'] = choice
        
        # Afficher les villes de dÃ©part disponibles
        keyboard = []
        # Ajouter les villes principales
        for city in SWISS_CITIES[:6]:  # Prendre les 6 premiÃ¨res villes
            keyboard.append([InlineKeyboardButton(city, callback_data=f"dep_{city}")])
        
        keyboard.append([InlineKeyboardButton("ğŸ” Autre ville", callback_data="other_city")])
        keyboard.append([InlineKeyboardButton("âŒ Annuler", callback_data="cancel_trip")])
        
        await query.edit_message_text(
            "ğŸš— CrÃ©ation d'un nouveau trajet\n\n"
            "1ï¸âƒ£ Choisissez la ville de dÃ©part:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return DEPARTURE
    else:
        # Premier affichage du menu de crÃ©ation
        keyboard = [
            [InlineKeyboardButton("ğŸš— Trajet simple", callback_data="trip_simple")],
            [InlineKeyboardButton("ğŸ”„ Trajet rÃ©gulier", callback_data="trip_regular")],
            [InlineKeyboardButton("âŒ Annuler", callback_data="cancel_trip")]
        ]
        
        await update.message.reply_text(
            "ğŸš— CrÃ©ation d'un nouveau trajet\n\n"
            "Quel type de trajet souhaitez-vous crÃ©er?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return TRIP_TYPE

async def handle_stop(update: Update, context):
    """GÃ¨re l'ajout d'un arrÃªt intermÃ©diaire"""
    if 'stops' not in context.user_data:
        context.user_data['stops'] = []
    
    new_stop = update.message.text
    if new_stop in SWISS_CITIES:
        context.user_data['stops'].append(new_stop)
        keyboard = [
            [InlineKeyboardButton("âœ… Terminer les arrÃªts", callback_data="stops_done")],
            [InlineKeyboardButton("â• Ajouter un autre arrÃªt", callback_data="stops_add")],
            [InlineKeyboardButton("âŒ Annuler", callback_data="stops_cancel")]
        ]
        await update.message.reply_text(
            f"ArrÃªt ajoutÃ©: {new_stop}\n"
            f"ArrÃªts actuels: {', '.join(context.user_data['stops'])}\n\n"
            "Voulez-vous ajouter un autre arrÃªt?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return ADDING_STOP
    else:
        await update.message.reply_text(
            "Cette ville n'est pas dans notre liste. Veuillez choisir une ville suisse valide."
        )
        return ADDING_STOP

async def finish_stops(update: Update, context):
    """Termine l'ajout des arrÃªts"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "stops_done":
        keyboard = [[
            InlineKeyboardButton("Confirmer", callback_data="confirm_trip"),
            InlineKeyboardButton("Annuler", callback_data="cancel_trip")
        ]]
        await query.message.edit_text(
            "RÃ©sumÃ© du trajet:\n"
            f"De: {context.user_data['departure']}\n"
            f"Ã€: {context.user_data['arrival']}\n"
            f"ArrÃªts: {', '.join(context.user_data['stops'])}\n"
            f"Date: {context.user_data['date']}\n"
            f"Places: {context.user_data['seats']}\n"
            f"Prix: {context.user_data['price']} CHF\n\n"
            "Confirmez-vous ces informations?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return CONFIRM
    elif query.data == "stops_add":
        await query.message.edit_text("Entrez le nom de la ville pour l'arrÃªt suivant:")
        return ADDING_STOP
    else:  # stops_cancel
        return await cancel(update, context)

async def add_meeting_point(update: Update, context):
    """Ajoute un point de rendez-vous prÃ©cis"""
    keyboard = [
        [InlineKeyboardButton("ğŸ“ Partager ma position", callback_data="share_location")],
        [InlineKeyboardButton("âœï¸ DÃ©crire le lieu", callback_data="describe_location")]
    ]
    await update.message.reply_text(
        "OÃ¹ exactement retrouverez-vous les passagers?\n"
        "Choisissez une option:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return MEETING_POINT

async def handle_trip_details(update: Update, context):
    """GÃ¨re les dÃ©tails supplÃ©mentaires du trajet"""
    keyboard = [
        [
            InlineKeyboardButton("ğŸ”„ Trajet rÃ©gulier", callback_data="recurring"),
            InlineKeyboardButton("â†©ï¸ Aller-retour", callback_data="round_trip")
        ],
        [
            InlineKeyboardButton("â° DÃ©lai rÃ©servation", callback_data="booking_deadline"),
            InlineKeyboardButton("ğŸ’º SiÃ¨ges spÃ©cifiques", callback_data="seat_selection")
        ]
    ]
    await update.message.reply_text(
        "Options supplÃ©mentaires:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def handle_other_city(update: Update, context):
    """GÃ¨re le choix d'une ville non listÃ©e"""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "ğŸ™ï¸ Entrez le nom de la ville:\n"
        "Par exemple: Bulle, Bienne, etc."
    )
    return DEPARTURE

async def handle_date(update: Update, context):
    """GÃ¨re l'entrÃ©e de la date"""
    try:
        date_str = update.message.text
        if not validate_date(date_str):
            await update.message.reply_text(
                "âŒ Format invalide! Utilisez le format: JJ/MM/AAAA HH:MM\n"
                "Par exemple: 25/04/2024 14:30"
            )
            return DATE
        
        context.user_data['date'] = date_str
        await update.message.reply_text(
            "Combien de places disponibles? (1-8)"
        )
        return SEATS

    except Exception as e:
        print(f"Error in handle_date: {e}")
        await update.message.reply_text("Une erreur est survenue. Utilisez /creer pour recommencer.")
        return ConversationHandler.END

async def handle_seats(update: Update, context):
    """GÃ¨re l'entrÃ©e du nombre de places"""
    try:
        seats = update.message.text
        if not validate_seats(seats):
            await update.message.reply_text("âŒ Nombre invalide! Choisissez entre 1 et 8 places.")
            return SEATS
        
        context.user_data['seats'] = seats
        await update.message.reply_text(
            "Quel est le prix par place en CHF?"
        )
        return PRICE

    except Exception as e:
        print(f"Error in handle_seats: {e}")
        await update.message.reply_text("Une erreur est survenue.")
        return ConversationHandler.END

async def handle_price(update: Update, context):
    """GÃ¨re l'entrÃ©e du prix"""
    try:
        price = update.message.text
        if not validate_price(price):
            await update.message.reply_text("âŒ Prix invalide! Le prix doit Ãªtre entre 1 et 1000 CHF.")
            return PRICE
        
        context.user_data['price'] = price
        
        # Afficher le rÃ©sumÃ©
        keyboard = [
            [
                InlineKeyboardButton("âœ… Confirmer", callback_data="confirm_trip"),
                InlineKeyboardButton("âŒ Annuler", callback_data="cancel_trip")
            ]
        ]
        
        await update.message.reply_text(
            "ğŸ“‹ RÃ©sumÃ© du trajet:\n\n"
            f"ğŸš— De: {context.user_data['departure']}\n"
            f"ğŸ Ã€: {context.user_data['arrival']}\n"
            f"ğŸ“… Date: {context.user_data['date']}\n"
            f"ğŸ’º Places: {context.user_data['seats']}\n"
            f"ğŸ’° Prix: {context.user_data['price']} CHF\n\n"
            "Tout est correct?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return CONFIRM

    except Exception as e:
        print(f"Error in handle_price: {e}")
        await update.message.reply_text("Une erreur est survenue.")
        return ConversationHandler.END

def get_popular_destinations():
    """Retourne une liste des destinations populaires"""
    # Ã€ implÃ©menter : rÃ©cupÃ©rer les destinations les plus frÃ©quentes
    return [
        {"name": "GenÃ¨ve", "zip": "1200", "canton": "GE"},
        {"name": "Lausanne", "zip": "1000", "canton": "VD"},
        {"name": "Berne", "zip": "3000", "canton": "BE"},
        {"name": "ZÃ¼rich", "zip": "8000", "canton": "ZH"},
        {"name": "BÃ¢le", "zip": "4000", "canton": "BS"}
    ]

async def start_trip(update: Update, context):
    """DÃ©marre le processus de crÃ©ation d'un trajet"""
    return await handle_trip_type(update, context)

def register(application):
    """Enregistre les handlers"""
    create_handler = ConversationHandler(
        entry_points=[
            CommandHandler('creer', create_trip),
            CallbackQueryHandler(create_trip, pattern='^create_trip$')
        ],
        states={
            TRIP_TYPE: [
                CallbackQueryHandler(handle_trip_type, pattern='^trip_'),
            ],
            DEPARTURE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_departure),
                CallbackQueryHandler(handle_departure, pattern='^dep_|^other_city$')
            ],
            ARRIVAL: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_arrival),
                CallbackQueryHandler(handle_arrival, pattern='^arr_|^other_arrival$')
            ],
            DATE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_date)
            ],
            SEATS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_seats)
            ],
            PRICE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_price)
            ],
            CONFIRM: [
                CallbackQueryHandler(confirm, pattern='^confirm_trip$'),
                CallbackQueryHandler(cancel, pattern='^cancel_trip$')
            ]
        },
        fallbacks=[
            CommandHandler('cancel', cancel),
            CallbackQueryHandler(cancel, pattern='^cancel_trip$')
        ]
    )

    search_handler = ConversationHandler(
        entry_points=[
            CommandHandler('chercher', search_trip),
            CallbackQueryHandler(search_trip, pattern='^search_trip$')
        ],
        states={
            ENTERING_DEPARTURE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_departure),
                CallbackQueryHandler(handle_departure, pattern='^from_')
            ],
            ENTERING_ARRIVAL: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_arrival),
                CallbackQueryHandler(handle_arrival, pattern='^to_')
            ]
        },
        fallbacks=[CommandHandler('cancel', cancel)]
    )

    # Handlers pour les commandes de base
    application.add_handler(create_handler)
    application.add_handler(search_handler)
    application.add_handler(CommandHandler("mes_trajets", list_my_trips))
    application.add_handler(CommandHandler("start", start_command))

async def start_command(update: Update, context: CallbackContext):
    """Commande /start"""
    keyboard = [
        [
            InlineKeyboardButton("ğŸš— CrÃ©er un trajet", callback_data="create_trip"),
            InlineKeyboardButton("ğŸ” Chercher un trajet", callback_data="search_trip")
        ],
        [
            InlineKeyboardButton("ğŸ“‹ Mes trajets", callback_data="my_trips")
        ]
    ]
    
    await update.message.reply_text(
        "ğŸ‘‹ Bienvenue sur CovoiturageSuisse!\n\n"
        "Que souhaitez-vous faire?",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
