#!/usr/bin/env python
# filepath: /Users/margaux/CovoiturageSuisse/handlers/trip_creation/common.py
"""
Fonctions communes pour la cr√©ation de trajets.
Module partag√© entre les handlers de conducteur et de passager.
"""
import logging
from datetime import datetime
from typing import Dict, Any, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import CallbackContext, CallbackQueryHandler
from database.models import Trip, User
from database import get_db

logger = logging.getLogger(__name__)

# Constantes pour les diff√©rents types de trajets
TRIP_TYPES = {
    "driver": {
        "name": "Conducteur",
        "emoji": "üöó",
        "description": "Vous proposez un trajet avec votre v√©hicule"
    },
    "passenger": {
        "name": "Passager",
        "emoji": "üë•",
        "description": "Vous cherchez un trajet en tant que passager"
    },
    "regular": {
        "name": "R√©gulier",
        "emoji": "üîÑ",
        "description": "Trajet qui se r√©p√®te chaque semaine"
    },
    "women_only": {
        "name": "Entre femmes",
        "emoji": "üë©",
        "description": "Trajet r√©serv√© aux femmes"
    }
}

def get_trip_creation_keyboard(include_women_only: bool = True) -> InlineKeyboardMarkup:
    """
    Cr√©e un clavier pour le choix du type de trajet.
    
    Args:
        include_women_only: Indique si l'option "Entre femmes" doit √™tre incluse
        
    Returns:
        InlineKeyboardMarkup avec les types de trajets
    """
    keyboard = [
        [
            InlineKeyboardButton(
                f"{TRIP_TYPES['driver']['emoji']} {TRIP_TYPES['driver']['name']}", 
                callback_data="trip_type:driver"
            ),
            InlineKeyboardButton(
                f"{TRIP_TYPES['passenger']['emoji']} {TRIP_TYPES['passenger']['name']}", 
                callback_data="trip_type:passenger"
            )
        ],
        [
            InlineKeyboardButton(
                f"{TRIP_TYPES['regular']['emoji']} {TRIP_TYPES['regular']['name']}", 
                callback_data="trip_type:regular"
            )
        ]
    ]
    
    if include_women_only:
        keyboard.append([
            InlineKeyboardButton(
                f"{TRIP_TYPES['women_only']['emoji']} {TRIP_TYPES['women_only']['name']}", 
                callback_data="trip_type:women_only"
            )
        ])
    
    # Bouton pour annuler
    keyboard.append([
        InlineKeyboardButton("‚ùå Annuler", callback_data="trip_type:cancel")
    ])
    
    return InlineKeyboardMarkup(keyboard)

async def handle_trip_type_selection(update: Update, context: CallbackContext):
    """
    G√®re la s√©lection du type de trajet.
    
    Args:
        update: Update Telegram
        context: Contexte de la conversation
        
    Returns:
        √âtat suivant dans la conversation
    """
    query = update.callback_query
    if not query:
        logger.error("‚ùå ERREUR: handle_trip_type_selection appel√© sans callback_query")
        return None
        
    logger.info(f"üîç INFO: handle_trip_type_selection appel√© avec callback_data={query.data} (user_id={update.effective_user.id})")
    
    # S'assurer que c'est bien un callback de type "trip_type"
    if not query.data or not query.data.startswith("trip_type:"):
        logger.error(f"‚ùå ERREUR: handle_trip_type_selection appel√© avec un callback_data invalide: {query.data}")
        return None
    
    try:
        # R√©pondre imm√©diatement au callback pour √©viter les erreurs de timeout
        await query.answer()
        
        # Extraire le type de trajet
        _, trip_type = query.data.split(':', 1)
        
        logger.info(f"‚úÖ Type de trajet s√©lectionn√©: {trip_type} (user_id={update.effective_user.id})")
        
        if trip_type == "cancel":
            # L'utilisateur annule
            try:
                await query.edit_message_text("‚ùå Cr√©ation de trajet annul√©e.")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Impossible d'√©diter le message d'annulation: {e}")
                # Envoyer un nouveau message si l'√©dition √©choue
                await query.message.reply_text("‚ùå Cr√©ation de trajet annul√©e.")
            return "CANCEL"
        
        # V√©rifier si le type est valide
        if trip_type not in TRIP_TYPES:
            logger.error(f"‚ùå Type de trajet non valide: {trip_type}")
            try:
                await query.edit_message_text("‚ùå Type de trajet non valide.")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Impossible d'√©diter le message d'erreur: {e}")
                await query.message.reply_text("‚ùå Type de trajet non valide.")
            return "CANCEL"
        
        # Sauvegarder le type dans le contexte
        context.user_data['trip_type'] = trip_type
        logger.debug(f"üîç DEBUG: Type de trajet '{trip_type}' sauvegard√© dans context.user_data")
        
        # Message de confirmation
        type_data = TRIP_TYPES[trip_type]
        try:
            await query.edit_message_text(
                f"{type_data['emoji']} *{type_data['name']}*\n\n"
                f"{type_data['description']}\n\n"
                "‚û°Ô∏è Passons aux d√©tails du trajet...",
                parse_mode=ParseMode.MARKDOWN
            )
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Impossible d'√©diter le message de confirmation: {e}")
            # Envoyer un nouveau message si l'√©dition √©choue
            await query.message.reply_text(
                f"{type_data['emoji']} *{type_data['name']}*\n\n"
                f"{type_data['description']}\n\n"
                "‚û°Ô∏è Passons aux d√©tails du trajet...",
                parse_mode=ParseMode.MARKDOWN
            )
        
        # D√©terminer l'√©tat suivant en fonction du type
        if trip_type == "driver":
            logger.info(f"üöó S√©lection type CONDUCTEUR: transition vers DRIVER_START, user_id={update.effective_user.id}")
            return "DRIVER_START"
        elif trip_type == "passenger":
            logger.info(f"üßç S√©lection type PASSAGER: transition vers PASSENGER_START, user_id={update.effective_user.id}")
            return "PASSENGER_START"
        elif trip_type == "regular":
            context.user_data['is_regular'] = True
            # Pour un trajet r√©gulier, demander d'abord si c'est en tant que conducteur ou passager
            keyboard = [
                [
                    InlineKeyboardButton("üöó Conducteur", callback_data="regular:driver"),
                    InlineKeyboardButton("üë• Passager", callback_data="regular:passenger")
                ],
                [InlineKeyboardButton("‚ùå Annuler", callback_data="regular:cancel")]
            ]
            try:
                await query.edit_message_text(
                    "üîÑ *Trajet r√©gulier*\n\n"
                    "√ätes-vous conducteur ou passager pour ce trajet r√©gulier?",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode=ParseMode.MARKDOWN
                )
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Impossible d'√©diter le message de trajet r√©gulier: {e}")
                await query.message.reply_text(
                    "üîÑ *Trajet r√©gulier*\n\n"
                    "√ätes-vous conducteur ou passager pour ce trajet r√©gulier?",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode=ParseMode.MARKDOWN
                )
            return "REGULAR_ROLE"
        elif trip_type == "women_only":
            context.user_data['women_only'] = True
            # Pour un trajet entre femmes, v√©rifier si l'utilisatrice est bien une femme
            user_id = update.effective_user.id
            db = get_db()
            user = db.query(User).filter_by(telegram_id=user_id).first()
            
            if user and user.gender == 'F':
                # C'est une femme, demander si c'est en tant que conductrice ou passag√®re
                keyboard = [
                    [
                        InlineKeyboardButton("üöó Conductrice", callback_data="women:driver"),
                        InlineKeyboardButton("üë• Passag√®re", callback_data="women:passenger")
                    ],
                    [InlineKeyboardButton("‚ùå Annuler", callback_data="women:cancel")]
                ]
                try:
                    await query.edit_message_text(
                        "üë© *Trajet entre femmes*\n\n"
                        "√ätes-vous conductrice ou passag√®re pour ce trajet?",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode=ParseMode.MARKDOWN
                    )
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Impossible d'√©diter le message pour femmes: {e}")
                    await query.message.reply_text(
                        "üë© *Trajet entre femmes*\n\n"
                        "√ätes-vous conductrice ou passag√®re pour ce trajet?",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode=ParseMode.MARKDOWN
                    )
                return "WOMEN_ROLE"
            else:
                # Ce n'est pas une femme ou le genre n'est pas d√©fini
                keyboard = [
                    [InlineKeyboardButton("‚úÖ Compl√©ter mon profil", callback_data="complete_profile")],
                    [InlineKeyboardButton("üîô Retour", callback_data="back_to_trip_type")]
                ]
                try:
                    await query.edit_message_text(
                        "‚ö†Ô∏è *Trajet entre femmes*\n\n"
                        "Ce type de trajet est r√©serv√© aux utilisatrices ayant "
                        "indiqu√© leur genre dans leur profil.\n\n"
                        "Veuillez compl√©ter votre profil avant de continuer.",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode=ParseMode.MARKDOWN
                    )
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Impossible d'√©diter le message de v√©rification femme: {e}")
                    await query.message.reply_text(
                        "‚ö†Ô∏è *Trajet entre femmes*\n\n"
                        "Ce type de trajet est r√©serv√© aux utilisatrices ayant "
                        "indiqu√© leur genre dans leur profil.\n\n"
                        "Veuillez compl√©ter votre profil avant de continuer.",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode=ParseMode.MARKDOWN
                    )
                return "WOMEN_ONLY_CHECK"
        
        # Cas par d√©faut si le type n'est pas reconnu mais valide
        return "CANCEL"
    
    except Exception as e:
        logger.error(f"‚ùå ERREUR dans handle_trip_type_selection: {e}", exc_info=True)
        try:
            await query.edit_message_text("‚ùå Une erreur s'est produite. Veuillez r√©essayer.")
        except Exception as edit_error:
            logger.error(f"‚ùå Erreur lors de l'√©dition du message apr√®s exception: {edit_error}")
            # Envoyer un nouveau message si l'√©dition √©choue
            try:
                await query.message.reply_text("‚ùå Une erreur s'est produite. Veuillez r√©essayer.")
            except Exception as reply_error:
                logger.error(f"‚ùå Erreur critique, impossible d'envoyer un message d'erreur: {reply_error}")
        return "CANCEL"

def format_trip_summary(trip_data: Dict[str, Any]) -> str:
    """
    Formate un r√©sum√© du trajet √† partir des donn√©es.
    
    Args:
        trip_data: Dictionnaire contenant les donn√©es du trajet
        
    Returns:
        Texte format√© avec le r√©sum√© du trajet
    """
    # D√©terminer s'il s'agit d'un trajet conducteur ou passager
    is_driver = trip_data.get('trip_type') == 'driver'
    role_emoji = "üöó" if is_driver else "üë•"
    role_text = "Conducteur" if is_driver else "Passager"
    
    # Formater la date et l'heure
    departure_date = trip_data.get('selected_datetime')
    date_str = departure_date.strftime('%d/%m/%Y √† %H:%M') if departure_date else "Non d√©finie"
    
    # Construire le r√©sum√©
    summary = [
        f"{role_emoji} *Trajet en tant que {role_text}*",
        "",
        f"üèôÔ∏è *D√©part:* {trip_data.get('departure', 'Non d√©fini')}",
        f"üèôÔ∏è *Arriv√©e:* {trip_data.get('arrival', 'Non d√©fini')}",
        f"üìÖ *Date:* {date_str}",
    ]
    
    # Ajouter les informations sp√©cifiques au conducteur
    if is_driver:
        seats = trip_data.get('seats', 0)
        price = trip_data.get('price', 0)
        
        summary.extend([
            f"üë• *Places:* {seats}",
            f"üí∞ *Prix par place:* {price} CHF"
        ])
        
        # Calcul de la commission
        if price:
            commission = price * 0.12  # 12% de commission
            driver_receives = price - commission
            summary.append(f"üí∏ *Vous recevrez:* {driver_receives:.2f} CHF par passager")
    
    # Ajouter les pr√©f√©rences si pr√©sentes
    preferences = trip_data.get('trip_preferences', {})
    if preferences:
        summary.append("")
        summary.append("üîß *Pr√©f√©rences:*")
        
        from handlers.preferences.trip_preferences_handler import PREFERENCES
        for pref_id, option_id in preferences.items():
            if pref_id in PREFERENCES:
                pref_data = PREFERENCES[pref_id]
                option_label = next(
                    (option['label'] for option in pref_data['options'] if option['id'] == option_id),
                    "Non d√©fini"
                )
                summary.append(f"  ‚úì {pref_data['name']}: {option_label}")
    
    # Ajouter les informations suppl√©mentaires
    additional_info = trip_data.get('additional_info')
    if additional_info:
        summary.append("")
        summary.append(f"üìù *Informations:* {additional_info}")
    
    # Ajouter des balises sp√©ciales
    if trip_data.get('is_regular'):
        summary.append("")
        summary.append("üîÑ Ce trajet est r√©gulier (hebdomadaire)")
    
    if trip_data.get('women_only'):
        summary.append("")
        summary.append("üë© Ce trajet est r√©serv√© aux femmes")
    
    return "\n".join(summary)

async def show_trip_summary(update: Update, context: CallbackContext, next_state: str):
    """
    Affiche un r√©sum√© du trajet avec des options pour confirmer ou modifier.
    
    Args:
        update: Update Telegram
        context: Contexte de la conversation
        next_state: √âtat suivant apr√®s confirmation
        
    Returns:
        √âtat suivant dans la conversation
    """
    query = None
    if update.callback_query:
        query = update.callback_query
        await query.answer()
    
    # R√©cup√©rer les donn√©es du trajet
    trip_data = context.user_data
    
    # Formater le r√©sum√©
    summary = format_trip_summary(trip_data)
    
    # Clavier pour confirmation
    keyboard = [
        [
            InlineKeyboardButton("‚úÖ Confirmer", callback_data="trip:confirm"),
            InlineKeyboardButton("‚úèÔ∏è Modifier", callback_data="trip:edit")
        ],
        [InlineKeyboardButton("‚ùå Annuler", callback_data="trip:cancel")]
    ]
    
    # Envoyer le message
    if query:
        await query.edit_message_text(
            f"üìã *R√©sum√© du trajet*\n\n{summary}\n\n"
            "Veuillez v√©rifier les informations et confirmer.",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.MARKDOWN
        )
    else:
        await update.message.reply_text(
            f"üìã *R√©sum√© du trajet*\n\n{summary}\n\n"
            "Veuillez v√©rifier les informations et confirmer.",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.MARKDOWN
        )
    
    # Stocker l'√©tat suivant dans le contexte
    context.user_data['next_state_after_confirm'] = next_state
    
    return "CONFIRMING_TRIP"

async def handle_trip_confirmation(update: Update, context: CallbackContext):
    """
    G√®re la confirmation ou modification d'un trajet.
    
    Args:
        update: Update Telegram
        context: Contexte de la conversation
        
    Returns:
        √âtat suivant dans la conversation
    """
    query = update.callback_query
    await query.answer()
    
    # Extraire l'action
    _, action = query.data.split(':', 1)
    
    if action == "confirm":
        # R√©cup√©rer l'√©tat suivant stock√©
        next_state = context.user_data.get('next_state_after_confirm', "END")
        
        # Confirmer le trajet
        await query.edit_message_text(
            "‚úÖ *Trajet confirm√©!*\n\n"
            "Votre trajet a √©t√© cr√©√© avec succ√®s.",
            parse_mode=ParseMode.MARKDOWN
        )
        
        # Passer √† l'√©tat suivant
        return next_state
    
    elif action == "edit":
        # Afficher les options de modification
        keyboard = [
            [InlineKeyboardButton("üèôÔ∏è D√©part", callback_data="edit:departure")],
            [InlineKeyboardButton("üèôÔ∏è Arriv√©e", callback_data="edit:arrival")],
            [InlineKeyboardButton("üìÖ Date et heure", callback_data="edit:datetime")]
        ]
        
        # Ajouter les boutons sp√©cifiques au conducteur/passager
        if context.user_data.get('trip_type') == 'driver':
            keyboard.extend([
                [InlineKeyboardButton("üë• Nombre de places", callback_data="edit:seats")],
                [InlineKeyboardButton("üí∞ Prix", callback_data="edit:price")]
            ])
        
        # Bouton pour les pr√©f√©rences
        keyboard.append([InlineKeyboardButton("üîß Pr√©f√©rences", callback_data="edit:preferences")])
        
        # Bouton pour les informations suppl√©mentaires
        keyboard.append([InlineKeyboardButton("üìù Informations", callback_data="edit:info")])
        
        # Bouton pour revenir au r√©sum√©
        keyboard.append([InlineKeyboardButton("üîô Retour", callback_data="edit:back")])
        
        await query.edit_message_text(
            "‚úèÔ∏è *Modifier le trajet*\n\n"
            "Que souhaitez-vous modifier?",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.MARKDOWN
        )
        
        return "EDITING_TRIP"
    
    elif action == "cancel":
        # Annuler la cr√©ation du trajet
        await query.edit_message_text(
            "‚ùå Cr√©ation de trajet annul√©e.",
            parse_mode=ParseMode.MARKDOWN
        )
        
        return "CANCEL"
    
    else:
        # Action non reconnue
        await query.edit_message_text("‚ùå Action non valide.")
        return "CANCEL"

async def handle_edit_selection(update: Update, context: CallbackContext):
    """
    G√®re la s√©lection d'un √©l√©ment √† √©diter.
    
    Args:
        update: Update Telegram
        context: Contexte de la conversation
        
    Returns:
        √âtat suivant dans la conversation
    """
    query = update.callback_query
    await query.answer()
    
    # Extraire l'√©l√©ment √† √©diter
    _, edit_item = query.data.split(':', 1)
    
    if edit_item == "back":
        # Revenir au r√©sum√© du trajet
        next_state = context.user_data.get('next_state_after_confirm', "END")
        return await show_trip_summary(update, context, next_state)
    
    # Stocker l'√©l√©ment √† √©diter
    context.user_data['editing_item'] = edit_item
    
    # G√©rer chaque type d'√©l√©ment
    if edit_item == "departure":
        # √âditer le lieu de d√©part
        from utils.location_picker import start_location_selection
        return await start_location_selection(
            update, context, 
            "departure", 
            "üèôÔ∏è S√©lectionnez une nouvelle ville de d√©part:"
        )
    
    elif edit_item == "arrival":
        # √âditer le lieu d'arriv√©e
        from utils.location_picker import start_location_selection
        return await start_location_selection(
            update, context, 
            "arrival", 
            "üèôÔ∏è S√©lectionnez une nouvelle ville d'arriv√©e:"
        )
    
    elif edit_item == "datetime":
        # √âditer la date et l'heure
        from utils.date_picker import start_date_selection
        return await start_date_selection(
            update, context,
            "üìÖ S√©lectionnez une nouvelle date pour votre trajet:"
        )
    
    elif edit_item == "seats":
        # √âditer le nombre de places
        keyboard = []
        for i in range(1, 9):
            keyboard.append([InlineKeyboardButton(str(i), callback_data=f"seats:{i}")])
        
        keyboard.append([InlineKeyboardButton("üîô Retour", callback_data="seats:back")])
        
        await query.edit_message_text(
            "üë• S√©lectionnez le nombre de places disponibles:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
        return "EDITING_SEATS"
    
    elif edit_item == "price":
        # √âditer le prix
        await query.edit_message_text(
            "üí∞ Entrez le nouveau prix par place (en CHF):"
        )
        
        return "EDITING_PRICE"
    
    elif edit_item == "preferences":
        # √âditer les pr√©f√©rences
        from handlers.preferences.trip_preferences_handler import show_preferences_menu
        return await show_preferences_menu(update, context)
    
    elif edit_item == "info":
        # √âditer les informations suppl√©mentaires
        await query.edit_message_text(
            "üìù Entrez les informations suppl√©mentaires pour ce trajet:"
        )
        
        return "EDITING_INFO"
    
    else:
        # √âl√©ment non reconnu
        await query.edit_message_text("‚ùå √âl√©ment √† √©diter non valide.")
        return "CANCEL"

# √âtats pour le module commun
common_states = {
    "CONFIRMING_TRIP": [
        CallbackQueryHandler(handle_trip_confirmation, pattern=r"^trip:(confirm|edit|cancel)$")
    ],
    "EDITING_TRIP": [
        CallbackQueryHandler(handle_edit_selection, pattern=r"^edit:.+$")
    ]
}
