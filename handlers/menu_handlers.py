from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    CallbackQueryHandler, 
    CommandHandler, 
    CallbackContext, 
    ConversationHandler, 
    MessageHandler, 
    filters,
    ContextTypes
)
from utils.languages import TRANSLATIONS
from database.models import User
from database import get_db

import logging
import asyncio
from handlers.create_trip_handler import start_create_trip as enter_create_trip_flow
from handlers.search_trip_handler import start_search_trip as enter_search_trip_flow
# Utiliser le nouveau gestionnaire de profil
from handlers.profile_handler import profile_handler

logger = logging.getLogger(__name__)

# States for driver availability conversation
DRIVER_OPTION, DRIVER_AVAILABILITY, DRIVER_AVAIL_TIME, DRIVER_AVAIL_SEATS, DRIVER_AVAIL_DEST, DRIVER_AVAIL_DEST_CITY, CONFIRM_AVAILABILITY = range(7)

# States for profile creation conversation
PROFILE_ROLE_SELECTION, PROFILE_NAME_INPUT, PROFILE_AGE_INPUT, PROFILE_PHONE_INPUT, PROFILE_PAYPAL_INPUT, PROFILE_COMPLETE = range(6)

# Fonction factice pour r√©soudre le probl√®me de v√©rification dans start_fixed_bot.py
# La vraie fonction sera import√©e dynamiquement dans handle_menu_selection
async def list_my_trips(update, context):
    """Fonction factice qui sera remplac√©e par l'import dynamique"""
    # Import dynamique pour √©viter les imports circulaires
    from handlers.trip_handlers import list_my_trips as real_list_my_trips
    return await real_list_my_trips(update, context)

# Fonction pour annuler une conversation
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annule la conversation en cours"""
    # Cas 1: Annulation via un callback
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        await query.edit_message_text("‚ùå Op√©ration annul√©e.")
    # Cas 2: Annulation via une commande
    elif update.message:
        await update.message.reply_text("‚ùå Op√©ration annul√©e.")
    
    # Nettoyer les donn√©es utilisateur
    context.user_data.clear()
    return ConversationHandler.END

async def start_command(update: Update, context: CallbackContext):
    """Commande /start am√©lior√©e avec v√©rification du profil utilisateur"""
    user_id = update.effective_user.id
    db = get_db()
    user = db.query(User).filter(User.telegram_id == user_id).first()
    
    if not user:
        # Nouvel utilisateur - proposer la cr√©ation de profil
        keyboard = [
            [InlineKeyboardButton("‚úÖ Cr√©er mon profil", callback_data="menu:create_profile")],
            [InlineKeyboardButton("‚ùì En savoir plus", callback_data="menu:help")]
        ]
        
        welcome_text = (
            "üëã *Bienvenue sur CovoiturageSuisse!*\n\n"
            "Pour utiliser l'application de covoiturage, vous devez d'abord cr√©er votre profil.\n\n"
            "üöó *Conducteur* : Proposez vos trajets et recevez des passagers (PayPal requis)\n"
            "üéí *Passager* : Trouvez des trajets et publiez vos demandes\n\n"
            "üí° *Vous pourrez cr√©er les deux types de profil si vous le souhaitez !*\n\n"
            "Cliquez ci-dessous pour commencer :"
        )
    else:
        # Utilisateur existant - v√©rifier s'il a les deux profils
        has_driver_profile = user.is_driver and user.paypal_email
        has_passenger_profile = True  # Tous les utilisateurs peuvent √™tre passagers
        
        if has_driver_profile and has_passenger_profile:
            # L'utilisateur a les deux profils - menu simplifi√©
            keyboard = [
                [
                    InlineKeyboardButton("üöó Cr√©er un trajet", callback_data="menu:create"),
                    InlineKeyboardButton("üîç Chercher un trajet", callback_data="menu:search_trip")
                ],
                [
                    InlineKeyboardButton("üìã Mes trajets", callback_data="menu:my_trips"),
                    InlineKeyboardButton("üë§ Mon profil", callback_data="menu:profile")
                ],
                [
                    InlineKeyboardButton("‚ùì Aide", callback_data="menu:help")
                ]
            ]
            
            welcome_text = (
                f"üëã *Bonjour {user.full_name or 'Utilisateur'}!*\n\n"
                f"üéØ **Vous avez acc√®s aux deux modes :**\n\n"
                f"üöó **Actions rapides disponibles :**\n"
                f"‚Ä¢ Cr√©er ou chercher des trajets\n"
                f"‚Ä¢ Chercher des passagers ou conducteurs\n"
                f"‚Ä¢ G√©rer vos trajets et profil\n\n"
                f"Que souhaitez-vous faire aujourd'hui ?"
            )
        elif has_driver_profile:
            # Uniquement profil conducteur - menu simplifi√©
            keyboard = [
                [
                    InlineKeyboardButton("üöó Cr√©er un trajet", callback_data="menu:create"),
                    InlineKeyboardButton("üîç Chercher un trajet", callback_data="menu:search_trip")
                ],
                [
                    InlineKeyboardButton("ÔøΩ Mes trajets", callback_data="menu:my_trips"),
                    InlineKeyboardButton("ÔøΩ Mon profil", callback_data="menu:profile")
                ],
                [
                    InlineKeyboardButton("‚ùì Aide", callback_data="menu:help")
                ]
            ]
            
            welcome_text = (
                f"üëã *Bonjour {user.full_name or 'Conducteur'}!*\n\n"
                f"üöó **Mode Conducteur actif**\n"
                f"Que souhaitez-vous faire aujourd'hui ?"
            )
        else:
            # Uniquement profil passager - proposer de cr√©er le profil conducteur
            keyboard = [
                [
                    InlineKeyboardButton("üöó Cr√©er un trajet", callback_data="menu:create"),
                    InlineKeyboardButton("üîç Chercher un trajet", callback_data="menu:search_trip")
                ],
                [
                    InlineKeyboardButton("üìã Mes trajets", callback_data="menu:my_trips"),
                    InlineKeyboardButton("üë§ Mon profil", callback_data="menu:profile")
                ],
                [
                    InlineKeyboardButton("üöó Devenir conducteur", callback_data="menu:become_driver"),
                    InlineKeyboardButton("‚ùì Aide", callback_data="menu:help")
                ]
            ]
            
            welcome_text = (
                f"üëã *Bonjour {user.full_name or 'Passager'}!*\n\n"
                f"üéí **Mode Passager actif**\n"
                f"Que souhaitez-vous faire aujourd'hui ?\n\n"
                f"üí° *Vous pouvez aussi devenir conducteur en configurant PayPal !*"
            )
    
    if update.message:
        await update.message.reply_text(welcome_text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
    elif update.callback_query:
        query = update.callback_query
        await query.answer()
        await query.edit_message_text(welcome_text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
    return ConversationHandler.END

async def handle_menu_buttons(update: Update, context: CallbackContext):
    """G√®re les clics sur les boutons du menu principal."""
    query = update.callback_query
    await query.answer()
    
    # Ajouter un log pour voir quel callback est intercept√©
    logger.info(f"Menu handler intercepted callback: {query.data}")
    
    # Ne pas intercepter les callbacks du profil ou menu:profile
    if query.data.startswith("profile:") or query.data == "menu:profile":
        logger.info(f"Menu handler: Ignorer le callback de profil: {query.data}")
        # Assurez-vous que le callback n'est pas g√©r√© par ce handler
        return ConversationHandler.END
    
    # V√©rifier si c'est un callback de calendrier, le menu handler ne devrait pas les intercepter
    if query.data.startswith("create_cal_") or query.data.startswith("calendar:"):
        logger.info(f"Menu handler: Ignorer le callback de calendrier: {query.data}")
        return  # Laissez-le √™tre g√©r√© par le gestionnaire de calendrier appropri√©
    
    action = query.data.split(":")[1] if ":" in query.data else query.data # e.g., "menu:create_trip" -> "create_trip"

    logger.info(f"Menu button clicked: {action}")
    
    # V√©rification du profil utilisateur pour les actions avanc√©es
    user_id = update.effective_user.id
    db = get_db()
    user = db.query(User).filter(User.telegram_id == user_id).first()

    if action == "create_profile":
        # D√©marrer le processus de cr√©ation de profil
        return await start_profile_creation(update, context)
    
    elif action == "search_trip" or action == "rechercher":
        # V√©rifier si l'utilisateur a un profil
        if not user:
            await query.edit_message_text(
                "‚ùå *Profil requis*\n\n"
                "Vous devez cr√©er un profil avant de pouvoir rechercher un trajet.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚úÖ Cr√©er mon profil", callback_data="menu:create_profile")],
                    [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
                ]),
                parse_mode="Markdown"
            )
            return ConversationHandler.END
        
        # This should call the entry point of the search_trip_conv_handler
        return await enter_search_trip_flow(update, context)
    
    elif query.data == "search_drivers":
        # Recherche de conducteurs pour les passagers - redirige vers la recherche normale
        if not user:
            await query.edit_message_text(
                "‚ùå *Profil requis*\n\n"
                "Vous devez cr√©er un profil avant de pouvoir rechercher des conducteurs.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚úÖ Cr√©er mon profil", callback_data="menu:create_profile")],
                    [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
                ]),
                parse_mode="Markdown"
            )
            return ConversationHandler.END
        
        # Rediriger vers la recherche de trajets avec le bon contexte
        return await enter_search_trip_flow(update, context)

    elif action == "my_trips":
        # V√©rifier si l'utilisateur a un profil
        if not user:
            await query.edit_message_text(
                "‚ùå *Profil requis*\n\n"
                "Vous devez cr√©er un profil avant de pouvoir voir vos trajets.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚úÖ Cr√©er un profil", callback_data="menu:create_profile")],
                    [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
                ]),
                parse_mode="Markdown"
            )
            return ConversationHandler.END
        
        # Utiliser la m√™me fonction que la commande /mes_trajets pour une exp√©rience coh√©rente
        from handlers.trip_handlers import list_my_trips
        return await list_my_trips(update, context)
        
    elif action == "profile":
        # Utiliser le nouveau gestionnaire de profil
        logger.info("Button profile clicked, redirecting to profile_handler")
        try:
            return await profile_handler(update, context)
        except Exception as e:
            logger.error(f"Error in profile_handler: {str(e)}", exc_info=True)
            await query.edit_message_text("Une erreur s'est produite lors de l'affichage du profil. Veuillez r√©essayer.")
            return ConversationHandler.END

    # NOTE: action == "create" is now handled by create_trip_conv_handler directly
    # No need to intercept it here anymore
    
    elif action == "help":
        return await show_help_menu(update, context)
    
    elif action == "become_driver":
        # Activer le profil conducteur et demander PayPal
        return await activate_driver_profile(update, context)
    
    elif query.data == "paypal_input_start":
        # Demander la saisie de l'email PayPal
        await query.edit_message_text(
            "üí≥ **Configuration PayPal**\n\n"
            "üìß Veuillez entrer votre adresse email PayPal :\n\n"
            "üí° *Exemple : votre-email@example.com*\n\n"
            "‚ö†Ô∏è Assurez-vous que l'email est correct, il sera utilis√© pour recevoir les paiements.",
            parse_mode="Markdown"
        )
        return PROFILE_PAYPAL_INPUT
    
    elif action == "back_to_main":
        # Retour au menu principal
        return await start_command(update, context)
    
    elif query.data == "setup_paypal":
        # Rediriger vers la configuration PayPal
        from handlers.paypal_setup_handler import request_paypal_email
        return await request_paypal_email(update, context)
    
    elif query.data.startswith("switch_profile:"):
        # G√©rer le changement de profil
        profile_type = query.data.split(":")[1]
        return await switch_user_profile(update, context, profile_type)
    
    elif query.data == "back_to_menu":
        # This is a common callback, ensure start_command handles callback_query
        return await start_command(update, context)
    
    # üîß CORRECTION: Nouveaux callbacks g√©r√©s
    elif query.data == "main_menu":
        return await start_command(update, context)
    
    elif query.data == "profile_main":
        from handlers.profile_handler import profile_handler
        return await profile_handler(update, context)
    
    elif query.data == "view_payments":
        await query.edit_message_text(
            "üí≥ *Mes paiements*\n\n"
            "Cette fonctionnalit√© sera bient√¥t disponible.\n"
            "En attendant, utilisez /paiements pour acc√©der aux options de paiement.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üè† Menu principal", callback_data="menu:back_to_main")]
            ]),
            parse_mode="Markdown"
        )
    
    elif query.data == "payment_history":
        await query.edit_message_text(
            "üìä *Historique des paiements*\n\n"
            "Cette fonctionnalit√© sera bient√¥t disponible.\n"
            "En attendant, utilisez /paiements pour acc√©der aux options de paiement.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üè† Menu principal", callback_data="menu:back_to_main")]
            ]),
            parse_mode="Markdown"
        )
    
    elif query.data == "search_passengers":
        # Rediriger vers la recherche de passagers
        keyboard = [
            [InlineKeyboardButton("‚ö° Vue rapide", callback_data="view_quick_passenger_trips")],
            [InlineKeyboardButton("üîç Recherche avanc√©e", callback_data="advanced_search_passengers")],
            [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
        ]
        await query.edit_message_text(
            "üöó *Recherche de passagers*\n\n"
            "Comment souhaitez-vous rechercher des passagers ?",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
    
    elif query.data == "search_drivers":
        # Rediriger vers la recherche de conducteurs
        await query.edit_message_text(
            "üîç *Recherche de conducteurs*\n\n"
            "Utilisez la recherche de trajets pour trouver des conducteurs disponibles.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîç Rechercher un trajet", callback_data="menu:search_trip")],
                [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
            ]),
            parse_mode="Markdown"
        )
    
    elif query.data == "why_paypal_required":
        await query.edit_message_text(
            "üí≥ *Pourquoi PayPal est requis ?*\n\n"
            "‚Ä¢ **S√©curit√©** : Paiements s√©curis√©s garantis\n"
            "‚Ä¢ **Automatisation** : Paiements automatiques apr√®s trajets\n"
            "‚Ä¢ **Protection** : Protection acheteur et vendeur\n"
            "‚Ä¢ **Rapidit√©** : Virements instantan√©s\n\n"
            "üí° Configuration PayPal gratuite et rapide !",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üí≥ Configurer PayPal", callback_data="setup_paypal")],
                [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
            ]),
            parse_mode="Markdown"
        )
    
    elif query.data == "ignore":
        # Pour les √©l√©ments de calendrier ou autres √©l√©ments non-cliquables
        await query.answer("‚ÑπÔ∏è √âl√©ment non-cliquable", show_alert=False)
        return

    # ... (handle other specific menu actions like public:driver_trips if not covered by sub-menus)
    
    # If an action leads to a conversation, it should return the first state of that conversation.
    # If it's a one-off action, it might return ConversationHandler.END or nothing if not in a conversation.
    # For now, assume menu buttons either start a new conversation (handled by their respective handlers) or display info.
    return # Or an appropriate state if this itself is part of a simple menu conversation

# ... (handle_role_choice, handle_driver_option, etc. for driver availability) ...
# These functions should be part of the availability_conv_handler
async def handle_role_choice(update: Update, context: CallbackContext):
    """G√®re le choix entre conducteur et passager pour disponibilit√© (example flow)."""
    query = update.callback_query
    await query.answer()
    
    # Example: This could be an entry point if 'menu:availability' was clicked
    # For now, this function is kept as an example; integrate it if you have a "declare availability" button
    # _, role = query.data.split(":", 1)
    # context.user_data['user_role'] = role
    # if role == "driver":
    #    # ...
    #    return DRIVER_OPTION
    await query.edit_message_text("D√©claration de disponibilit√© en cours de d√©veloppement.")
    return ConversationHandler.END


# Placeholder for cancel function if not already globally available
async def cancel_conversation(update: Update, context: CallbackContext):
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text("Op√©ration annul√©e.")
    else:
        await update.message.reply_text("Op√©ration annul√©e.")
    context.user_data.clear()
    return ConversationHandler.END

# Example ConversationHandler for driver availability (if you implement this flow)
# availability_conv_handler = ConversationHandler(
# entry_points=[CallbackQueryHandler(handle_role_choice, pattern='^role:(driver|passenger)$')],
# states={
# DRIVER_OPTION: [CallbackQueryHandler(handle_driver_option, pattern='^driver_option:(specific|available)$')],
# DRIVER_AVAILABILITY: [
# CallbackQueryHandler(handle_driver_availability, pattern='^avail_from_'),
# CallbackQueryHandler(handle_driver_availability, pattern='^avail_other_city$'),
# MessageHandler(filters.TEXT & ~filters.COMMAND, handle_driver_availability)
# ],
#         # ... other states ...
#     },
# fallbacks=[CallbackQueryHandler(cancel_conversation, pattern='^cancel_trip$')]
# )

def register(application):
    application.add_handler(CommandHandler("start", start_command))
    # General handler for menu callbacks that don't start a new major conversation
    # N'interceptez que des motifs tr√®s sp√©cifiques pour √©viter les conflits avec d'autres handlers
    application.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern="^menu:(?!profile$|create$).*"))  # Exclure menu:profile et menu:create
    application.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern="^back_to_menu$"))
    # Ajoutez les callbacks sp√©cifiques pour les boutons de menu principaux
    # REMOVED: creer_trajet is now handled by create_trip_conv_handler
    application.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern="^rechercher$"))
    # Ne pas g√©rer "profil" ici car il est g√©r√© par profile_handler
    application.add_handler(CallbackQueryHandler(handle_menu_buttons, pattern="^mes_trajets$"))


    # Add other handlers specific to menu_handlers.py, like the availability_conv_handler if used
    # application.add_handler(availability_conv_handler)

    # Handler for public trip listings if not part of search_handler
    # application.add_handler(CallbackQueryHandler(handle_public_trips, pattern="^public:"))
    logger.info("Menu handlers registered.")

async def start_profile_creation(update: Update, context: CallbackContext):
    """D√©marre le processus de cr√©ation de profil guid√©"""
    query = update.callback_query
    
    keyboard = [
        [InlineKeyboardButton("üöó Conducteur", callback_data="profile_create:driver")],
        [InlineKeyboardButton("üéí Passager", callback_data="profile_create:passenger")],
        [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
    ]
    
    text = (
        "üë§ *Cr√©ation de votre profil*\n\n"
        "Choisissez votre r√¥le principal :\n\n"
        "üöó *Conducteur*\n"
        "‚Ä¢ Proposez vos trajets\n"
        "‚Ä¢ Recevez des paiements via PayPal\n"
        "‚Ä¢ G√©rez vos passagers\n\n"
        "üéí *Passager*\n"
        "‚Ä¢ Recherchez des trajets\n"
        "‚Ä¢ R√©servez facilement\n"
        "‚Ä¢ Payez en ligne\n\n"
        "‚ö†Ô∏è Vous pourrez cr√©er les deux profils si besoin."
    )
    
    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    # Retourner l'√©tat pour d√©marrer le ConversationHandler d'inscription
    return PROFILE_ROLE_SELECTION

async def show_help_menu(update: Update, context: CallbackContext):
    """Affiche le menu d'aide complet"""
    query = update.callback_query if update.callback_query else None
    
    keyboard = [
        [InlineKeyboardButton("üöó Aide conducteur", callback_data="help:driver")],
        [InlineKeyboardButton("üéí Aide passager", callback_data="help:passenger")],
        [InlineKeyboardButton("ü§ù Nouveau syst√®me", callback_data="help:dual_system")],
        [InlineKeyboardButton("üí≥ Paiements PayPal", callback_data="help:paypal")],
        [InlineKeyboardButton("‚ùì FAQ", callback_data="help:faq")],
        [InlineKeyboardButton("üìû Contact", callback_data="help:contact")],
        [InlineKeyboardButton("üîô Menu principal", callback_data="menu:back_to_main")]
    ]
    
    text = (
        "‚ùì *Centre d'aide CovoiturageSuisse*\n\n"
        "S√©lectionnez le sujet pour lequel vous avez besoin d'aide :\n\n"
        "üöó **Aide conducteur** - Comment proposer vos services et cr√©er des trajets\n"
        "üéí **Aide passager** - Comment chercher ET cr√©er des demandes de trajet\n"
        "ü§ù **Nouveau syst√®me** - Guide complet du syst√®me dual-role\n"
        "üí≥ **Paiements PayPal** - Configuration et gestion des paiements\n"
        "‚ùì **FAQ** - Questions fr√©quemment pos√©es\n"
        "üìû **Contact** - Nous contacter pour un support personnalis√©"
    )
    
    if query:
        await query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
    else:
        await update.message.reply_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
    return ConversationHandler.END

async def switch_user_profile(update: Update, context: CallbackContext, profile_type: str):
    """Change le profil actif de l'utilisateur (conducteur/passager) et redirige vers le profil complet"""
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    db = get_db()
    user = db.query(User).filter(User.telegram_id == user_id).first()
    
    if not user:
        await query.edit_message_text("‚ùå Profil utilisateur non trouv√©.")
        return ConversationHandler.END
    
    # NOUVEAU: V√©rifier PayPal pour tous les profils
    if not user.paypal_email:
        keyboard = [
            [InlineKeyboardButton("üí≥ Configurer PayPal", callback_data="setup_paypal")],
            [InlineKeyboardButton("‚ùì Pourquoi PayPal ?", callback_data="why_paypal_required")],
            [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
        ]
        
        role_text = "conducteur" if profile_type == "driver" else "passager"
        
        await query.edit_message_text(
            f"üîí *Configuration PayPal Requise*\n\n"
            f"Pour activer votre profil {role_text}, vous devez "
            f"configurer votre email PayPal.\n\n"
            f"üí° **Pourquoi PayPal est obligatoire ?**\n"
            f"‚Ä¢ S√©curit√© des transactions\n"
            f"‚Ä¢ Remboursements automatiques\n"
            f"‚Ä¢ Protection acheteur/vendeur\n\n"
            f"üëá Configurez maintenant :",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return ConversationHandler.END
    
    # V√©rifier et activer le profil selon le type demand√©
    if profile_type == "driver":
        # V√©rifier que l'utilisateur a un profil conducteur complet
        if not user.is_driver:
            keyboard = [
                [InlineKeyboardButton("üí≥ Activer profil conducteur", callback_data="menu:become_driver")],
                [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
            ]
            
            await query.edit_message_text(
                "üöó *Activation du Mode Conducteur*\n\n"
                "‚ùå Votre profil conducteur n'est pas activ√©.\n"
                "Activez-le pour pouvoir cr√©er des trajets et recevoir des passagers.\n\n"
                "üí≥ PayPal d√©j√† configur√© :",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown"
            )
            return ConversationHandler.END
    
    # Enregistrer le profil actuel dans context.user_data
    context.user_data['active_profile'] = profile_type
    
    db.close()
    
    # MODIFICATION IMPORTANTE: Rediriger vers le profil complet au lieu d'afficher le mini-profil
    # Afficher un message de confirmation rapide puis rediriger
    role_text = "Conducteur" if profile_type == "driver" else "Passager"
    
    await query.edit_message_text(
        f"‚úÖ *Mode {role_text} Activ√©*\n\n"
        f"Redirection vers votre profil...",
        parse_mode="Markdown"
    )
    
    # Attendre un petit moment puis rediriger vers le profil complet
    import asyncio
    await asyncio.sleep(1)
    
    # Rediriger vers la fonction profile_handler pour afficher le profil complet
    return await profile_handler(update, context)

async def activate_driver_profile(update: Update, context: CallbackContext):
    """Active le profil conducteur et demande la configuration PayPal"""
    query = update.callback_query
    user_id = update.effective_user.id
    
    db = get_db()
    user = db.query(User).filter(User.telegram_id == user_id).first()
    
    if not user:
        await query.edit_message_text(
            "‚ùå Erreur : Profil utilisateur non trouv√©.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
            ])
        )
        return ConversationHandler.END
    
    # Activer le profil conducteur
    user.is_driver = True
    db.commit()
    
    # V√©rifier si l'utilisateur a d√©j√† un email PayPal
    if user.paypal_email:
        keyboard = [
            [InlineKeyboardButton("üöó Cr√©er un trajet", callback_data="menu:create")],
            [InlineKeyboardButton("üí≥ Modifier PayPal", callback_data="setup_paypal")],
            [InlineKeyboardButton("üîô Menu principal", callback_data="menu:back_to_main")]
        ]
        
        text = (
            "‚úÖ *Profil conducteur activ√© !*\n\n"
            f"üìß Email PayPal : `{user.paypal_email}`\n\n"
            "Vous pouvez maintenant cr√©er des trajets et recevoir des paiements."
        )
    else:
        keyboard = [
            [InlineKeyboardButton("üí≥ Configurer PayPal", callback_data="setup_paypal")],
            [InlineKeyboardButton("‚è≠Ô∏è Configurer plus tard", callback_data="menu:back_to_main")]
        ]
        
        text = (
            "‚úÖ *Profil conducteur activ√© !*\n\n"
            "üîî *Configuration PayPal recommand√©e*\n\n"
            "Pour recevoir des paiements automatiques, "
            "configurez votre email PayPal maintenant.\n\n"
            "‚ö†Ô∏è Sans PayPal configur√©, vous ne pourrez pas recevoir de paiements automatiques."
        )
    
    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return ConversationHandler.END

# Fonction pour g√©rer la commande /aide directement
async def aide_command(update: Update, context: CallbackContext):
    """Commande /aide accessible depuis n'importe o√π"""
    return await show_help_menu(update, context)

async def handle_profile_creation(update: Update, context: CallbackContext):
    """G√®re la cr√©ation de profil selon le r√¥le choisi"""
    query = update.callback_query
    await query.answer()
    
    action = query.data.split(":")[1]  # profile_create:driver ou profile_create:passenger
    
    # Stocker le r√¥le choisi
    context.user_data['selected_role'] = action
    
    # Demander le nom complet
    await query.edit_message_text(
        f"üë§ *Inscription - √âtape 1/4*\n\n"
        f"üéØ R√¥le choisi : {'üöó Conducteur' if action == 'driver' else 'üéí Passager'}\n\n"
        f"ÔøΩ **Veuillez entrer votre nom complet :**\n"
        f"(Pr√©nom et nom de famille)\n\n"
        f"üí° Ce nom sera visible par les autres utilisateurs.",
        parse_mode="Markdown"
    )
    
    return PROFILE_NAME_INPUT

async def handle_profile_name_input(update: Update, context: CallbackContext):
    """G√®re la saisie du nom complet"""
    user_input = update.message.text.strip()
    
    if len(user_input) < 2:
        await update.message.reply_text(
            "‚ùå Le nom doit contenir au moins 2 caract√®res.\n"
            "Veuillez entrer votre nom complet :"
        )
        return PROFILE_NAME_INPUT
    
    context.user_data['full_name'] = user_input
    
    await update.message.reply_text(
        f"üë§ *Inscription - √âtape 2/4*\n\n"
        f"‚úÖ Nom : {user_input}\n\n"
        f"üéÇ **Veuillez entrer votre √¢ge :**\n"
        f"(Entre 18 et 99 ans)\n\n"
        f"üí° Cette information aide √† cr√©er la confiance entre utilisateurs.",
        parse_mode="Markdown"
    )
    
    return PROFILE_AGE_INPUT

async def handle_profile_age_input(update: Update, context: CallbackContext):
    """G√®re la saisie de l'√¢ge"""
    try:
        age = int(update.message.text.strip())
        if age < 18 or age > 99:
            await update.message.reply_text(
                "‚ùå L'√¢ge doit √™tre compris entre 18 et 99 ans.\n"
                "Veuillez entrer votre √¢ge :"
            )
            return PROFILE_AGE_INPUT
    except ValueError:
        await update.message.reply_text(
            "‚ùå Veuillez entrer un nombre valide.\n"
            "Quel est votre √¢ge ?"
        )
        return PROFILE_AGE_INPUT
    
    context.user_data['age'] = age
    
    await update.message.reply_text(
        f"üë§ *Inscription - √âtape 3/4*\n\n"
        f"‚úÖ Nom : {context.user_data['full_name']}\n"
        f"‚úÖ √Çge : {age} ans\n\n"
        f"üì± **Veuillez entrer votre num√©ro de t√©l√©phone :**\n"
        f"(Format : +41 79 123 45 67 ou 079 123 45 67)\n\n"
        f"üí° N√©cessaire pour les confirmations de trajet.",
        parse_mode="Markdown"
    )
    
    return PROFILE_PHONE_INPUT

async def handle_profile_phone_input(update: Update, context: CallbackContext):
    """G√®re la saisie du t√©l√©phone"""
    phone = update.message.text.strip()
    
    # Validation basique du num√©ro de t√©l√©phone
    if len(phone) < 10 or not any(char.isdigit() for char in phone):
        await update.message.reply_text(
            "‚ùå Format de t√©l√©phone invalide.\n"
            "Veuillez entrer un num√©ro valide (ex: +41 79 123 45 67) :"
        )
        return PROFILE_PHONE_INPUT
    
    context.user_data['phone'] = phone
    selected_role = context.user_data.get('selected_role', 'passenger')
    
    # NOUVEAU: PayPal obligatoire pour TOUS (conducteurs ET passagers)
    keyboard = [
        [InlineKeyboardButton("üìß Entrer mon adresse email PayPal", callback_data="paypal_input_start")],
        [InlineKeyboardButton("üÜï Cr√©er un compte PayPal", url="https://www.paypal.com/ch/webapps/mpp/account-selection")],
        [InlineKeyboardButton("‚ùì Pourquoi PayPal est obligatoire ?", callback_data="why_paypal_required")]
    ]
    
    role_text = "Conducteur" if selected_role == 'driver' else "Passager"
    
    await update.message.reply_text(
        f"üë§ *Inscription - √âtape 4/4*\n\n"
        f"‚úÖ Nom : {context.user_data['full_name']}\n"
        f"‚úÖ √Çge : {context.user_data['age']} ans\n"
        f"‚úÖ T√©l√©phone : {phone}\n\n"
        f"üí≥ **Configuration PayPal ({role_text})**\n\n"
        f"Pour garantir la s√©curit√© des transactions, PayPal est obligatoire pour tous les utilisateurs :\n\n"
        f"‚Ä¢ **Conducteurs** : Recevoir les paiements automatiques (88% du montant)\n"
        f"‚Ä¢ **Passagers** : Recevoir les remboursements en cas d'annulation\n\n"
        f"ÔøΩ **S√©curit√© garantie** : Protection acheteur/vendeur PayPal\n\n"
        f"üëá **Choisissez une option :**",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return PROFILE_PAYPAL_INPUT

async def handle_paypal_input_start(update: Update, context: CallbackContext):
    """G√®re le clic sur le bouton 'Entrer mon adresse email PayPal'"""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        f"üí≥ **Configuration PayPal - √âtape finale**\n\n"
        f"üìß **Veuillez entrer votre adresse email PayPal :**\n\n"
        f"üí° Assurez-vous que :\n"
        f"‚Ä¢ L'email est correctement √©crit\n"
        f"‚Ä¢ C'est bien votre email PayPal principal\n"
        f"‚Ä¢ Votre compte PayPal est actif\n\n"
        f"‚ö†Ô∏è Cette adresse sera utilis√©e pour recevoir les paiements.",
        parse_mode="Markdown"
    )
    
    return PROFILE_PAYPAL_INPUT

async def handle_why_paypal_required(update: Update, context: CallbackContext):
    """Explique pourquoi PayPal est obligatoire pour tous"""
    query = update.callback_query
    await query.answer()
    
    keyboard = [
        [InlineKeyboardButton("üìß Configurer PayPal maintenant", callback_data="paypal_input_start")],
        [InlineKeyboardButton("üîô Retour", callback_data="back_to_phone_input")]
    ]
    
    await query.edit_message_text(
        "üí° *Pourquoi PayPal est obligatoire ?*\n\n"
        "**üîí S√©curit√© pour tous :**\n"
        "‚Ä¢ Protection acheteur/vendeur PayPal\n"
        "‚Ä¢ Transactions 100% s√©curis√©es\n"
        "‚Ä¢ Historique complet des paiements\n\n"
        "**üí∞ Avantages conducteurs :**\n"
        "‚Ä¢ Paiements automatiques (88% du montant)\n"
        "‚Ä¢ Pas de gestion d'argent liquide\n"
        "‚Ä¢ Commission plateforme (12%) pr√©lev√©e automatiquement\n\n"
        "**üõ°Ô∏è Avantages passagers :**\n"
        "‚Ä¢ Remboursements automatiques en cas d'annulation\n"
        "‚Ä¢ Protection en cas de litige\n"
        "‚Ä¢ Paiements en un clic, pas de liquide\n\n"
        "üéØ **R√©sultat :** Covoiturage 100% digital et s√©curis√© !",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return PROFILE_PAYPAL_INPUT

async def handle_profile_paypal_input(update: Update, context: CallbackContext):
    """G√®re la saisie de l'email PayPal pour les conducteurs"""
    email = update.message.text.strip()
    
    # Validation basique de l'email
    if '@' not in email or '.' not in email:
        await update.message.reply_text(
            "‚ùå Format d'email invalide.\n"
            "Veuillez entrer une adresse email PayPal valide :"
        )
        return PROFILE_PAYPAL_INPUT
    
    context.user_data['paypal_email'] = email
    
    return await complete_profile_creation(update, context)

async def complete_profile_creation(update: Update, context: CallbackContext):
    """Finalise la cr√©ation du profil avec toutes les informations"""
    user_id = update.effective_user.id
    user_data = update.effective_user
    selected_role = context.user_data.get('selected_role', 'passenger')
    
    db = get_db()
    
    # Cr√©er le profil utilisateur complet
    new_user = User(
        telegram_id=user_id,
        full_name=context.user_data['full_name'],
        username=user_data.username,
        age=context.user_data['age'],
        phone=context.user_data['phone'],
        paypal_email=context.user_data.get('paypal_email') or None,
        is_driver=(selected_role == "driver"),
        is_passenger=True  # Tous les utilisateurs peuvent √™tre passagers
    )
    
    db.add(new_user)
    db.commit()
    
    # Message de succ√®s personnalis√©
    if selected_role == 'driver':
        keyboard = [
            [InlineKeyboardButton("üöó Cr√©er mon premier trajet", callback_data="menu:create")],
            [InlineKeyboardButton("üë§ Voir mon profil", callback_data="menu:profile")],
            [InlineKeyboardButton("üè† Menu principal", callback_data="menu:back_to_main")]
        ]
        
        text = (
            f"üéâ *Profil conducteur cr√©√© avec succ√®s !*\n\n"
            f"üëã Bienvenue {new_user.full_name} !\n\n"
            f"‚úÖ **Votre profil :**\n"
            f"‚Ä¢ Nom : {new_user.full_name}\n"
            f"‚Ä¢ √Çge : {new_user.age} ans\n"
            f"‚Ä¢ T√©l√©phone : {new_user.phone}\n"
            f"‚Ä¢ PayPal : {new_user.paypal_email}\n\n"
            f"üöó **Vous pouvez maintenant :**\n"
            f"‚Ä¢ Cr√©er des trajets\n"
            f"‚Ä¢ Recevoir des paiements automatiques\n"
            f"‚Ä¢ G√©rer vos passagers\n\n"
            f"Pr√™t √† proposer votre premier trajet ?"
        )
    else:
        keyboard = [
            [InlineKeyboardButton("üîç Chercher un trajet", callback_data="menu:search_trip")],
            [InlineKeyboardButton("üë§ Voir mon profil", callback_data="menu:profile")],
            [InlineKeyboardButton("üè† Menu principal", callback_data="menu:back_to_main")]
        ]
        
        text = (
            f"üéâ *Profil passager cr√©√© avec succ√®s !*\n\n"
            f"üëã Bienvenue {new_user.full_name} !\n\n"
            f"‚úÖ **Votre profil :**\n"
            f"‚Ä¢ Nom : {new_user.full_name}\n"
            f"‚Ä¢ √Çge : {new_user.age} ans\n"
            f"‚Ä¢ T√©l√©phone : {new_user.phone}\n\n"
            f"üéí **Vous pouvez maintenant :**\n"
            f"‚Ä¢ Rechercher des trajets\n"
            f"‚Ä¢ R√©server des places\n"
            f"‚Ä¢ Payer en ligne\n\n"
            f"Pr√™t √† partir √† l'aventure ?"
        )
    
    if update.message:
        await update.message.reply_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
    else:
        await update.callback_query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
    
    # Nettoyer les donn√©es temporaires
    context.user_data.clear()
    return ConversationHandler.END

async def cancel_profile_creation(update: Update, context: CallbackContext):
    """Annule la cr√©ation de profil"""
    context.user_data.clear()
    
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text(
            "‚ùå Cr√©ation de profil annul√©e.\n\n"
            "Vous pouvez recommencer √† tout moment avec /start"
        )
    else:
        await update.message.reply_text(
            "‚ùå Cr√©ation de profil annul√©e.\n\n"
            "Vous pouvez recommencer √† tout moment avec /start"
        )
    
    return ConversationHandler.END

async def handle_help_callbacks(update: Update, context: CallbackContext):
    """G√®re les callbacks d'aide contextuelle"""
    query = update.callback_query
    await query.answer()
    
    help_type = query.data.split(":")[1]  # help:driver, help:passenger, etc.
    
    if help_type == "driver":
        text = (
            "üöó *Aide Conducteur*\n\n"
            "**üí° NOUVEAU : Deux fa√ßons de proposer vos services !**\n\n"
            "**1Ô∏è‚É£ Cr√©er un trajet classique :**\n"
            "‚Ä¢ Cr√©er ‚Üí Conducteur ‚Üí D√©finir votre trajet\n"
            "‚Ä¢ Les passagers vous trouvent et r√©servent\n\n"
            "**2Ô∏è‚É£ R√©pondre aux demandes de passagers :**\n"
            "‚Ä¢ Menu ‚Üí 'Demandes passagers'\n"
            "‚Ä¢ Consultez les demandes publi√©es\n"
            "‚Ä¢ Proposez vos services personnalis√©s\n"
            "‚Ä¢ Prix calcul√© automatiquement par km\n\n"
            "**üìã √âtapes pour proposer un service :**\n"
            "1. S√©lectionnez une demande de trajet\n"
            "2. R√©digez un message de pr√©sentation\n"
            "3. Confirmez votre tarif (prix/km standard)\n"
            "4. D√©crivez votre v√©hicule\n"
            "5. Indiquez le point de ramassage\n"
            "6. Envoyez votre proposition\n\n"
            "**‚úÖ Avantages du nouveau syst√®me :**\n"
            "‚Ä¢ Plus de flexibilit√© dans les trajets\n"
            "‚Ä¢ Contact direct avec les passagers\n"
            "‚Ä¢ Tarification transparente et √©quitable\n"
            "‚Ä¢ Paiement s√©curis√© via PayPal"
        )
    elif help_type == "passenger":
        text = (
            "üéí *Aide Passager*\n\n"
            "**üí° NOUVEAU : Trois fa√ßons de voyager !**\n\n"
            "**1Ô∏è‚É£ Chercher des trajets existants :**\n"
            "‚Ä¢ Chercher ‚Üí Parcourir les trajets disponibles\n"
            "‚Ä¢ R√©server directement en ligne\n\n"
            "**2Ô∏è‚É£ Publier votre demande de trajet :**\n"
            "‚Ä¢ Cr√©er ‚Üí Passager ‚Üí Publier votre demande\n"
            "‚Ä¢ Les conducteurs vous contactent\n"
            "‚Ä¢ Choisissez la meilleure proposition\n\n"
            "**3Ô∏è‚É£ Cr√©er un trajet comme passager :**\n"
            "‚Ä¢ Pr√©cisez que vous cherchez UN conducteur\n"
            "‚Ä¢ Les conducteurs voient votre annonce\n"
            "‚Ä¢ Ils vous proposent leurs services\n\n"
            "**üìã Comment publier une demande :**\n"
            "1. Cr√©er un trajet en mode 'Passager'\n"
            "2. Indiquez vos villes de d√©part/arriv√©e\n"
            "3. D√©finissez date, heure et flexibilit√©\n"
            "4. Pr√©cisez nombre de places et budget\n"
            "5. Publiez votre demande\n"
            "6. Recevez des propositions de conducteurs\n\n"
            "**üöó Quand les conducteurs vous contactent :**\n"
            "‚Ä¢ Consultez les d√©tails de chaque proposition\n"
            "‚Ä¢ Comparez v√©hicules, horaires et conducteurs\n"
            "‚Ä¢ Prix calcul√© automatiquement par km\n"
            "‚Ä¢ Acceptez la meilleure offre\n"
            "‚Ä¢ Payez en ligne via PayPal\n"
            "‚Ä¢ Contactez votre conducteur\n\n"
            "**‚úÖ Avantages du nouveau syst√®me :**\n"
            "‚Ä¢ Plus de choix et flexibilit√©\n"
            "‚Ä¢ Prix transparent et √©quitable\n"
            "‚Ä¢ Paiement s√©curis√©\n"
            "‚Ä¢ Contact direct avec conducteurs\n"
            "‚Ä¢ Vous n'attendez plus, vous publiez !"
        )
    elif help_type == "dual_system":
        text = (
            "ü§ù *Guide du Nouveau Syst√®me Dual-Role*\n\n"
            "**üéØ Concept :**\n"
            "CovoiturageSuisse fonctionne maintenant comme une marketplace o√π passagers et conducteurs peuvent se trouver mutuellement !\n\n"
            "**üë• Pour les PASSAGERS :**\n"
            "‚úÖ Publiez vos demandes de trajet\n"
            "‚úÖ Recevez des propositions personnalis√©es\n"
            "‚úÖ Choisissez votre conducteur pr√©f√©r√©\n"
            "‚úÖ Prix calcul√© automatiquement par km\n\n"
            "**üöó Pour les CONDUCTEURS :**\n"
            "‚úÖ Cr√©ez vos trajets classiques\n"
            "‚úÖ Consultez les demandes de passagers\n"
            "‚úÖ Proposez vos services sur mesure\n"
            "‚úÖ Tarification transparente et √©quitable\n\n"
            "**üîÑ Processus de matching :**\n"
            "1. Passager publie une demande\n"
            "2. Conducteurs voient la demande\n"
            "3. Conducteurs proposent leurs services\n"
            "4. Passager choisit et accepte\n"
            "5. Paiement automatique via PayPal\n"
            "6. Confirmation et √©change de contacts\n\n"
            "**üéØ R√©sultat :**\n"
            "Plus de trajets, plus de flexibilit√©, plus de choix pour tous !"
        )
    elif help_type == "paypal":
        text = (
            "üí≥ *Paiements PayPal*\n\n"
            "**Configuration conducteur :**\n"
            "‚Ä¢ Allez dans votre profil\n"
            "‚Ä¢ Cliquez sur 'Configurer PayPal'\n"
            "‚Ä¢ Entrez votre email PayPal\n"
            "‚Ä¢ Activez les paiements automatiques\n\n"
            "**Paiements passager :**\n"
            "‚Ä¢ Les paiements se font via PayPal\n"
            "‚Ä¢ S√©curis√© et instantan√©\n"
            "‚Ä¢ Confirmation automatique\n\n"
            "**S√©curit√© :**\n"
            "‚Ä¢ Vos donn√©es sont prot√©g√©es\n"
            "‚Ä¢ Garantie de remboursement PayPal\n"
            "‚Ä¢ Support 24h/24"
        )
    elif help_type == "faq":
        text = (
            "‚ùì *Questions Fr√©quentes*\n\n"
            "**Q: Quelle est la diff√©rence entre cr√©er un trajet conducteur et passager ?**\n"
            "R: Conducteur = vous proposez votre v√©hicule. Passager = vous cherchez un conducteur et publiez votre demande.\n\n"
            "**Q: Comment les conducteurs voient-ils ma demande de trajet ?**\n"
            "R: Votre demande appara√Æt dans 'Demandes passagers' du menu principal pour tous les conducteurs.\n\n"
            "**Q: Puis-je n√©gocier le prix avec un conducteur ?**\n"
            "R: Les prix sont calcul√©s automatiquement selon la distance (CHF par km). Pas de n√©gociation n√©cessaire, tarification √©quitable pour tous.\n\n"
            "**Q: Que se passe-t-il si plusieurs conducteurs me contactent ?**\n"
            "R: Vous recevez toutes les propositions et choisissez celle qui vous convient le mieux.\n\n"
            "**Q: Comment annuler une demande de trajet ?**\n"
            "R: Allez dans 'Mes trajets' et supprimez votre demande si aucune proposition n'a √©t√© accept√©e.\n\n"
            "**Q: Le paiement est-il s√©curis√© ?**\n"
            "R: Oui, tous les paiements passent par PayPal avec protection acheteur.\n\n"
            "**Q: Comment contacter un conducteur apr√®s acceptation ?**\n"
            "R: Les coordonn√©es sont √©chang√©es automatiquement apr√®s paiement confirm√©.\n\n"
            "**Q: Puis-je √™tre √† la fois conducteur et passager ?**\n"
            "R: Absolument ! Vous pouvez publier des demandes ET proposer vos services selon vos besoins."
        )
    elif help_type == "contact":
        text = (
            "üìû *Nous Contacter*\n\n"
            "**Support technique :**\n"
            "‚Ä¢ Email: support@covoiturage-suisse.ch\n"
            "‚Ä¢ Telegram: @CovoiturageSuisseSupport\n\n"
            "**Questions g√©n√©rales :**\n"
            "‚Ä¢ Email: contact@covoiturage-suisse.ch\n"
            "‚Ä¢ T√©l√©phone: +41 XX XXX XX XX\n\n"
            "**Urgences s√©curit√© :**\n"
            "‚Ä¢ Num√©ro d'urgence: 117 (Police)\n"
            "‚Ä¢ Email urgent: urgent@covoiturage-suisse.ch\n\n"
            "**Horaires support :**\n"
            "Lundi-Vendredi: 8h-18h\n"
            "Weekend: 10h-16h"
        )
    else:
        text = "‚ùå Section d'aide non trouv√©e."
    
    keyboard = [
        [InlineKeyboardButton("üîô Retour aide", callback_data="menu:help")],
        [InlineKeyboardButton("üè† Menu principal", callback_data="menu:back_to_main")]
    ]
    
    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return ConversationHandler.END

async def handle_profile_created_actions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """G√©rer les actions apr√®s cr√©ation du profil"""
    query = update.callback_query
    await query.answer()
    
    action = query.data
    
    if action == "setup_paypal":
        # Rediriger vers la configuration PayPal
        from handlers.paypal_setup_handler import start_paypal_setup
        return await start_paypal_setup(update, context)
    elif action == "add_vehicle":
        # Rediriger vers l'ajout de v√©hicule
        from handlers.vehicle_handler import start_vehicle_setup
        return await start_vehicle_setup(update, context)
    elif action == "main_menu":
        # Retourner au menu principal
        from .menu_handlers import show_main_menu
        await show_main_menu(update, context)
        return ConversationHandler.END
    
    return ConversationHandler.END

# ConversationHandler pour la cr√©ation compl√®te de profil
profile_creation_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_profile_creation, pattern=r"^menu:create_profile$"),
    ],
    states={
        PROFILE_ROLE_SELECTION: [
            CallbackQueryHandler(handle_profile_creation, pattern=r"^profile_create:(driver|passenger)$"),
            CallbackQueryHandler(cancel_profile_creation, pattern=r"^menu:back_to_main$")
        ],
        PROFILE_NAME_INPUT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_profile_name_input),
            CommandHandler("cancel", cancel_profile_creation)
        ],
        PROFILE_AGE_INPUT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_profile_age_input),
            CommandHandler("cancel", cancel_profile_creation)
        ],
        PROFILE_PHONE_INPUT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_profile_phone_input),
            CommandHandler("cancel", cancel_profile_creation)
        ],
        PROFILE_PAYPAL_INPUT: [
            CallbackQueryHandler(handle_paypal_input_start, pattern=r"^paypal_input_start$"),
            CallbackQueryHandler(handle_why_paypal_required, pattern=r"^why_paypal_required$"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_profile_paypal_input),
            CommandHandler("cancel", cancel_profile_creation)
        ]
    },
    fallbacks=[
        CommandHandler("cancel", cancel_profile_creation),
        CallbackQueryHandler(cancel_profile_creation, pattern=r"^menu:back_to_main$")
    ],
    name="profile_creation",
    persistent=True,
    allow_reentry=True,
    per_message=False
)
