"""
Gestionnaires Telegram pour les paiements PayPal
Gestion des commandes de paiement et int√©gration avec PayPal
"""

import logging
import json
from typing import Optional, Dict, Any
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, filters
from database.db_manager import get_db
from database.models import User, Trip, Booking
from paypal_utils import create_trip_payment, complete_trip_payment, pay_driver
import asyncio
from contextlib import contextmanager

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# √âtats pour le ConversationHandler
WAITING_PAYPAL_EMAIL = 1

@contextmanager
def get_db_session():
    """Context manager pour g√©rer les sessions de base de donn√©es"""
    session = get_db()
    try:
        yield session
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()

class PaymentHandlers:
    """Gestionnaires pour les paiements PayPal"""
    
    @staticmethod
    async def set_paypal_email_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """
        Commande /definirpaypal - Enregistrer l'email PayPal d'un utilisateur
        """
        user = update.effective_user
        
        await update.message.reply_text(
            "üè¶ *Configuration PayPal*\n\n"
            "Pour recevoir vos paiements de covoiturage, nous avons besoin de votre adresse email PayPal.\n\n"
            "‚ö†Ô∏è *Important :* Assurez-vous que cette adresse email est bien associ√©e √† votre compte PayPal.\n\n"
            "üìß Veuillez saisir votre adresse email PayPal :",
            parse_mode='Markdown'
        )
        
        return WAITING_PAYPAL_EMAIL
    
    @staticmethod
    async def save_paypal_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """
        Sauvegarde l'email PayPal de l'utilisateur
        """
        email = update.message.text.strip()
        user_id = update.effective_user.id
        
        # Validation basique de l'email
        if '@' not in email or '.' not in email:
            await update.message.reply_text(
                "‚ùå Adresse email invalide. Veuillez saisir une adresse email valide :",
                parse_mode='Markdown'
            )
            return WAITING_PAYPAL_EMAIL
        
        try:
            with get_db_session() as session:
                # Recherche de l'utilisateur
                user = session.query(User).filter(User.telegram_id == user_id).first()
                
                if not user:
                    await update.message.reply_text(
                        "‚ùå Utilisateur non trouv√©. Veuillez d'abord vous inscrire avec /start"
                    )
                    return ConversationHandler.END
                
                # Mise √† jour de l'email PayPal
                user.paypal_email = email
                session.commit()
                
                await update.message.reply_text(
                    f"‚úÖ *Email PayPal enregistr√© avec succ√®s !*\n\n"
                    f"üìß Email : `{email}`\n\n"
                    f"Vous pouvez maintenant recevoir des paiements pour vos trajets en tant que conducteur.",
                    parse_mode='Markdown'
                )
                
                logger.info(f"Email PayPal enregistr√© pour l'utilisateur {user_id}: {email}")
        except Exception as e:
            logger.error(f"Erreur lors de l'enregistrement de l'email PayPal : {e}")
            await update.message.reply_text(
                "‚ùå Erreur lors de l'enregistrement. Veuillez r√©essayer plus tard."
            )
        
        return ConversationHandler.END
    
    @staticmethod
    async def cancel_paypal_setup(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """
        Annule la configuration PayPal
        """
        await update.message.reply_text("‚ùå Configuration PayPal annul√©e.")
        return ConversationHandler.END
    
    @staticmethod
    async def pay_trip_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Commande /payer <id_trajet> - Initier un paiement pour un trajet
        """
        user_id = update.effective_user.id
        
        # V√©rification des arguments
        if not context.args:
            await update.message.reply_text(
                "‚ùå Usage : `/payer <id_trajet>`\n\n"
                "Exemple : `/payer 123`",
                parse_mode='Markdown'
            )
            return
        
        try:
            trip_id = int(context.args[0])
        except ValueError:
            await update.message.reply_text(
                "‚ùå ID de trajet invalide. Veuillez saisir un nombre."
            )
            return
        
        try:
            with get_db_session() as session:
                # V√©rification de l'existence du trajet
                trip = session.query(Trip).filter(Trip.id == trip_id).first()
                if not trip:
                    await update.message.reply_text(
                        f"‚ùå Trajet #{trip_id} non trouv√©."
                    )
                    return
                
                # V√©rification que l'utilisateur a une r√©servation pour ce trajet
                booking = session.query(Booking).filter(
                    Booking.trip_id == trip_id,
                    Booking.passenger_id == user_id,
                    Booking.status == 'confirmed'
                ).first()
                
                if not booking:
                    await update.message.reply_text(
                        f"‚ùå Vous n'avez pas de r√©servation confirm√©e pour le trajet #{trip_id}."
                    )
                    return
                
                # V√©rification que le paiement n'a pas d√©j√† √©t√© effectu√©
                if booking.payment_status == 'paid':
                    await update.message.reply_text(
                        f"‚úÖ Vous avez d√©j√† pay√© pour le trajet #{trip_id}."
                    )
                    return
                
                # R√©cup√©ration du conducteur
                driver = session.query(User).filter(User.telegram_id == trip.driver_id).first()
                if not driver:
                    await update.message.reply_text(
                        "‚ùå Conducteur non trouv√©."
                    )
                    return
                
                # Cr√©ation du paiement PayPal
                trip_description = f"{trip.departure_city} ‚Üí {trip.arrival_city}"
                success, payment_id, approval_url = create_trip_payment(
                    amount=float(booking.total_price),
                    trip_description=trip_description
                )
                
                if success and payment_id and approval_url:
                    # Sauvegarde de l'ID de paiement
                    booking.paypal_payment_id = payment_id
                    booking.payment_status = 'pending'
                    session.commit()
                    
                    # Cr√©ation du clavier avec le lien PayPal
                    keyboard = [
                        [InlineKeyboardButton("üí≥ Payer avec PayPal", url=approval_url)],
                        [InlineKeyboardButton("‚ùå Annuler", callback_data=f"cancel_payment_{trip_id}")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await update.message.reply_text(
                        f"üí∞ *Paiement du trajet #{trip_id}*\n\n"
                        f"üöó Trajet : {trip_description}\n"
                        f"üë§ Conducteur : {driver.full_name or 'Nom non d√©fini'}\n"
                        f"üíµ Montant : {booking.total_price} CHF\n\n"
                        f"Cliquez sur le bouton ci-dessous pour proc√©der au paiement PayPal :",
                        parse_mode='Markdown',
                        reply_markup=reply_markup
                    )
                    
                    logger.info(f"Paiement initi√© pour le trajet {trip_id}, montant: {booking.total_price} CHF")
                    
                else:
                    await update.message.reply_text(
                        "‚ùå Erreur lors de la cr√©ation du paiement PayPal. Veuillez r√©essayer plus tard."
                    )
                    
        except Exception as e:
            logger.error(f"Erreur lors de l'initiation du paiement : {e}")
            await update.message.reply_text(
                "‚ùå Erreur lors de l'initiation du paiement. Veuillez r√©essayer plus tard."
            )
    
    @staticmethod
    async def confirm_trip_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Commande /confirmer <id_trajet> - Valider un trajet et payer le conducteur
        Utilis√© par le conducteur pour confirmer que le trajet a √©t√© effectu√©
        """
        user_id = update.effective_user.id
        
        # V√©rification des arguments
        if not context.args:
            await update.message.reply_text(
                "‚ùå Usage : `/confirmer <id_trajet>`\n\n"
                "Exemple : `/confirmer 123`",
                parse_mode='Markdown'
            )
            return
        
        try:
            trip_id = int(context.args[0])
        except ValueError:
            await update.message.reply_text(
                "‚ùå ID de trajet invalide. Veuillez saisir un nombre."
            )
            return
        
        try:
            with get_db_session() as session:
                # V√©rification que le trajet existe et appartient au conducteur
                trip = session.query(Trip).filter(
                    Trip.id == trip_id,
                    Trip.driver_id == user_id
                ).first()
                
                if not trip:
                    await update.message.reply_text(
                        f"‚ùå Trajet #{trip_id} non trouv√© ou vous n'√™tes pas le conducteur."
                    )
                    return
                
                # V√©rification que le trajet n'a pas d√©j√† √©t√© confirm√©
                if trip.status == 'completed':
                    await update.message.reply_text(
                        f"‚úÖ Le trajet #{trip_id} a d√©j√† √©t√© confirm√©."
                    )
                    return
                
                # R√©cup√©ration du conducteur
                driver = session.query(User).filter(User.telegram_id == user_id).first()
                if not driver or not hasattr(driver, 'paypal_email') or not driver.paypal_email:
                    await update.message.reply_text(
                        "‚ùå Vous devez d'abord configurer votre email PayPal avec /definirpaypal"
                    )
                    return
                
                # R√©cup√©ration des r√©servations pay√©es pour ce trajet
                paid_bookings = session.query(Booking).filter(
                    Booking.trip_id == trip_id,
                    Booking.payment_status == 'paid'
                ).all()
                
                if not paid_bookings:
                    await update.message.reply_text(
                        f"‚ùå Aucun passager n'a encore pay√© pour le trajet #{trip_id}."
                    )
                    return
                
                # Calcul du montant total √† verser au conducteur
                total_amount = sum(float(booking.total_price) for booking in paid_bookings)
                
                # Envoi du paiement au conducteur (88% du montant)
                success, payout_batch_id = pay_driver(
                    driver_email=driver.paypal_email,
                    trip_amount=total_amount
                )
                
                if success:
                    # Mise √† jour du statut du trajet
                    trip.status = 'completed'
                    trip.payout_batch_id = payout_batch_id
                    
                    # Mise √† jour des r√©servations
                    for booking in paid_bookings:
                        booking.status = 'completed'
                    
                    session.commit()
                    
                    driver_amount = round(total_amount * 0.88, 2)
                    commission = round(total_amount * 0.12, 2)
                    
                    await update.message.reply_text(
                        f"‚úÖ *Trajet #{trip_id} confirm√© !*\n\n"
                        f"üí∞ Montant total collect√© : {total_amount} CHF\n"
                        f"üíµ Votre part (88%) : {driver_amount} CHF\n"
                        f"üè¶ Commission (12%) : {commission} CHF\n\n"
                        f"üí≥ Le paiement a √©t√© envoy√© √† votre compte PayPal : {driver.paypal_email}\n\n"
                        f"Merci d'avoir utilis√© notre service de covoiturage ! üöó",
                        parse_mode='Markdown'
                    )
                    
                    # Notification aux passagers
                    for booking in paid_bookings:
                        passenger = session.query(User).filter(User.telegram_id == booking.passenger_id).first()
                        if passenger:
                            try:
                                await context.bot.send_message(
                                    chat_id=passenger.telegram_id,
                                    text=f"‚úÖ *Trajet termin√© !*\n\n"
                                         f"üöó Trajet #{trip_id} : {trip.departure_city} ‚Üí {trip.arrival_city}\n"
                                         f"üë§ Conducteur : {driver.full_name or 'Nom non d√©fini'}\n\n"
                                         f"Merci d'avoir voyag√© avec nous ! N'h√©sitez pas √† laisser un avis sur le conducteur.",
                                    parse_mode='Markdown'
                                )
                            except Exception as e:
                                logger.error(f"Erreur lors de l'envoi de notification au passager {passenger.telegram_id}: {e}")
                    
                    logger.info(f"Trajet {trip_id} confirm√©, paiement de {driver_amount} CHF envoy√© au conducteur")
                    
                else:
                    await update.message.reply_text(
                        "‚ùå Erreur lors de l'envoi du paiement PayPal. Veuillez contacter le support."
                    )
                    
        except Exception as e:
            logger.error(f"Erreur lors de la confirmation du trajet : {e}")
            await update.message.reply_text(
                "‚ùå Erreur lors de la confirmation du trajet. Veuillez r√©essayer plus tard."
            )
    
    @staticmethod
    async def payment_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Gestionnaire pour les callbacks de paiement
        """
        query = update.callback_query
        await query.answer()
        
        data = query.data
        user_id = update.effective_user.id
        
        if data.startswith("cancel_payment_"):
            trip_id = int(data.split("_")[2])
            
            try:
                with get_db_session() as session:
                    # Annulation du paiement en cours
                    booking = session.query(Booking).filter(
                        Booking.trip_id == trip_id,
                        Booking.passenger_id == user_id,
                        Booking.payment_status == 'pending'
                    ).first()
                    
                    if booking:
                        booking.payment_status = 'cancelled'
                        booking.paypal_payment_id = None
                        session.commit()
                
                await query.edit_message_text(
                    f"‚ùå Paiement du trajet #{trip_id} annul√©."
                )
                
            except Exception as e:
                logger.error(f"Erreur lors de l'annulation du paiement : {e}")
                await query.edit_message_text(
                    "‚ùå Erreur lors de l'annulation. Veuillez r√©essayer."
                )
    
    @staticmethod
    async def webhook_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Gestionnaire pour les webhooks PayPal
        Cette fonction serait appel√©e par un endpoint web s√©par√©
        """
        # Cette fonction serait normalement appel√©e par un serveur web
        # qui re√ßoit les webhooks PayPal
        pass
    
    @staticmethod
    async def check_payment_status_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Commande /statut_paiement - V√©rifier le statut des paiements
        """
        user_id = update.effective_user.id
        
        try:
            with get_db_session() as session:
                # R√©cup√©ration des r√©servations en cours de l'utilisateur
                bookings = session.query(Booking).filter(
                    Booking.passenger_id == user_id,
                    Booking.payment_status.in_(['pending', 'paid'])
                ).join(Trip).all()
                
                if not bookings:
                    await update.message.reply_text(
                        "‚ÑπÔ∏è Vous n'avez aucun paiement en cours."
                    )
                    return
                
                message = "üí≥ *Statut de vos paiements :*\n\n"
                
                for booking in bookings:
                    trip = booking.trip
                    status_emoji = "‚è≥" if booking.payment_status == 'pending' else "‚úÖ"
                    status_text = "En attente" if booking.payment_status == 'pending' else "Pay√©"
                    
                    message += (
                        f"{status_emoji} *Trajet #{trip.id}*\n"
                        f"üöó {trip.departure_city} ‚Üí {trip.arrival_city}\n"
                        f"üí∞ {booking.total_price} CHF - {status_text}\n\n"
                    )
                
                await update.message.reply_text(message, parse_mode='Markdown')
                
        except Exception as e:
            logger.error(f"Erreur lors de la v√©rification du statut des paiements : {e}")
            await update.message.reply_text(
                "‚ùå Erreur lors de la v√©rification. Veuillez r√©essayer plus tard."
            )


# Cr√©ation du ConversationHandler pour la configuration PayPal
paypal_setup_conv_handler = ConversationHandler(
    entry_points=[CommandHandler('definirpaypal', PaymentHandlers.set_paypal_email_command)],
    states={
        WAITING_PAYPAL_EMAIL: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, PaymentHandlers.save_paypal_email),
            CommandHandler('cancel', PaymentHandlers.cancel_paypal_setup),
            CommandHandler('annuler', PaymentHandlers.cancel_paypal_setup),
        ],
    },
    fallbacks=[
        CommandHandler('cancel', PaymentHandlers.cancel_paypal_setup),
        CommandHandler('annuler', PaymentHandlers.cancel_paypal_setup),
    ],
    allow_reentry=True
)

# Gestionnaires de commandes
payment_command_handlers = [
    CommandHandler('payer', PaymentHandlers.pay_trip_command),
    CommandHandler('confirmer', PaymentHandlers.confirm_trip_command),
    CommandHandler('statut_paiement', PaymentHandlers.check_payment_status_command),
]

# Gestionnaire de callbacks
payment_callback_handler = CallbackQueryHandler(
    PaymentHandlers.payment_callback_handler,
    pattern=r'^(cancel_payment_|confirm_payment_)'
)


def get_payment_handlers():
    """
    Retourne tous les gestionnaires de paiement √† ajouter √† l'application
    """
    return {
        'conversation_handlers': [paypal_setup_conv_handler],
        'command_handlers': payment_command_handlers,
        'callback_handlers': [payment_callback_handler]
    }


if __name__ == "__main__":
    print("‚úÖ Gestionnaires de paiement PayPal configur√©s")
    print("Commandes disponibles :")
    print("  /definirpaypal - Configurer l'email PayPal")
    print("  /payer <id_trajet> - Payer un trajet")
    print("  /confirmer <id_trajet> - Confirmer un trajet (conducteur)")
    print("  /statut_paiement - V√©rifier le statut des paiements")
