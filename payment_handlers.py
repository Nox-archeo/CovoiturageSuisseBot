"""
Gestionnaires Telegram pour les paiements PayPal
Gestion des commandes de paiement et int√©gration avec PayPal
"""

import logging
import json
from typing import Optional, Dict, Any
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, filters
from database.db_manager import get_db
from database.models import User, Trip, Booking
from paypal_utils import create_trip_payment, complete_trip_payment, pay_driver
from utils.swiss_pricing import round_to_nearest_0_05, format_swiss_price
import asyncio
from contextlib import contextmanager

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# √âtats pour le ConversationHandler
WAITING_PAYPAL_EMAIL = 1

@contextmanager
def get_db_session():
    """Context manager pour g√©rer les sessions de base de donn√©es"""
    session = get_db()
    try:
        yield session
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()

class PaymentHandlers:
    """Gestionnaires pour les paiements PayPal"""
    
    @staticmethod
    async def set_paypal_email_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """
        Commande /definirpaypal - Enregistrer l'email PayPal d'un utilisateur
        """
        user = update.effective_user
        
        await update.message.reply_text(
            "üè¶ *Configuration PayPal*\n\n"
            "Pour recevoir vos paiements de covoiturage, nous avons besoin de votre adresse email PayPal.\n\n"
            "‚ö†Ô∏è *Important :* Assurez-vous que cette adresse email est bien associ√©e √† votre compte PayPal.\n\n"
            "üìß Veuillez saisir votre adresse email PayPal :",
            parse_mode='Markdown'
        )
        
        return WAITING_PAYPAL_EMAIL
    
    @staticmethod
    async def save_paypal_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """
        Sauvegarde l'email PayPal de l'utilisateur
        """
        email = update.message.text.strip()
        user_id = update.effective_user.id
        
        # Validation basique de l'email
        if '@' not in email or '.' not in email:
            await update.message.reply_text(
                "‚ùå Adresse email invalide. Veuillez saisir une adresse email valide :",
                parse_mode='Markdown'
            )
            return WAITING_PAYPAL_EMAIL
        
        try:
            with get_db_session() as session:
                # Recherche de l'utilisateur
                user = session.query(User).filter(User.telegram_id == user_id).first()
                
                if not user:
                    await update.message.reply_text(
                        "‚ùå Utilisateur non trouv√©. Veuillez d'abord vous inscrire avec /start"
                    )
                    return ConversationHandler.END
                
                # Mise √† jour de l'email PayPal
                user.paypal_email = email
                session.commit()
                
                await update.message.reply_text(
                    f"‚úÖ *Email PayPal enregistr√© avec succ√®s !*\n\n"
                    f"üìß Email : `{email}`\n\n"
                    f"Vous pouvez maintenant recevoir des paiements pour vos trajets en tant que conducteur.",
                    parse_mode='Markdown'
                )
                
                logger.info(f"Email PayPal enregistr√© pour l'utilisateur {user_id}: {email}")
        except Exception as e:
            logger.error(f"Erreur lors de l'enregistrement de l'email PayPal : {e}")
            await update.message.reply_text(
                "‚ùå Erreur lors de l'enregistrement. Veuillez r√©essayer plus tard."
            )
        
        return ConversationHandler.END
    
    @staticmethod
    async def cancel_paypal_setup(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """
        Annule la configuration PayPal
        """
        await update.message.reply_text("‚ùå Configuration PayPal annul√©e.")
        return ConversationHandler.END
    
    @staticmethod
    async def pay_trip_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Commande /payer <id_trajet> - Initier un paiement pour un trajet
        """
        user_id = update.effective_user.id
        
        # V√©rification des arguments
        if not context.args:
            await update.message.reply_text(
                "‚ùå Usage : `/payer <id_trajet>`\n\n"
                "Exemple : `/payer 123`",
                parse_mode='Markdown'
            )
            return
        
        try:
            trip_id = int(context.args[0])
        except ValueError:
            await update.message.reply_text(
                "‚ùå ID de trajet invalide. Veuillez saisir un nombre."
            )
            return
        
        try:
            with get_db_session() as session:
                # V√©rification de l'existence du trajet
                trip = session.query(Trip).filter(Trip.id == trip_id).first()
                if not trip:
                    await update.message.reply_text(
                        f"‚ùå Trajet #{trip_id} non trouv√©."
                    )
                    return
                
                # V√©rification que l'utilisateur a une r√©servation pour ce trajet
                booking = session.query(Booking).filter(
                    Booking.trip_id == trip_id,
                    Booking.passenger_id == user_id,
                    Booking.status == 'confirmed'
                ).first()
                
                if not booking:
                    await update.message.reply_text(
                        f"‚ùå Vous n'avez pas de r√©servation confirm√©e pour le trajet #{trip_id}."
                    )
                    return
                
                # V√©rification que le paiement n'a pas d√©j√† √©t√© effectu√©
                if booking.payment_status == 'paid':
                    await update.message.reply_text(
                        f"‚úÖ Vous avez d√©j√† pay√© pour le trajet #{trip_id}."
                    )
                    return
                
                # R√©cup√©ration du conducteur
                driver = session.query(User).filter(User.telegram_id == trip.driver_id).first()
                if not driver:
                    await update.message.reply_text(
                        "‚ùå Conducteur non trouv√©."
                    )
                    return
                
                # Cr√©ation du paiement PayPal
                trip_description = f"{trip.departure_city} ‚Üí {trip.arrival_city}"
                success, payment_id, approval_url = create_trip_payment(
                    amount=float(booking.total_price),
                    trip_description=trip_description
                )
                
                if success and payment_id and approval_url:
                    # Sauvegarde de l'ID de paiement
                    booking.paypal_payment_id = payment_id
                    booking.payment_status = 'pending'
                    session.commit()
                    
                    # Cr√©ation du clavier avec le lien PayPal
                    keyboard = [
                        [InlineKeyboardButton("üí≥ Payer avec PayPal", url=approval_url)],
                        [InlineKeyboardButton("‚ùå Annuler", callback_data=f"cancel_payment_{trip_id}")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await update.message.reply_text(
                        f"üí∞ *Paiement du trajet #{trip_id}*\n\n"
                        f"üöó Trajet : {trip_description}\n"
                        f"üë§ Conducteur : {driver.full_name or 'Nom non d√©fini'}\n"
                        f"üíµ Montant : {format_swiss_price(booking.total_price)} CHF\n\n"
                        f"Cliquez sur le bouton ci-dessous pour proc√©der au paiement PayPal :",
                        parse_mode='Markdown',
                        reply_markup=reply_markup
                    )
                    
                    logger.info(f"Paiement initi√© pour le trajet {trip_id}, montant: {format_swiss_price(booking.total_price)} CHF")
                    
                else:
                    await update.message.reply_text(
                        "‚ùå Erreur lors de la cr√©ation du paiement PayPal. Veuillez r√©essayer plus tard."
                    )
                    
        except Exception as e:
            logger.error(f"Erreur lors de l'initiation du paiement : {e}")
            await update.message.reply_text(
                "‚ùå Erreur lors de l'initiation du paiement. Veuillez r√©essayer plus tard."
            )
    
    @staticmethod
    async def confirm_trip_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Commande /confirmer <id_trajet> - Valider un trajet et payer le conducteur
        Utilis√© par le conducteur pour confirmer que le trajet a √©t√© effectu√©
        """
        user_id = update.effective_user.id
        
        # V√©rification des arguments
        if not context.args:
            await update.message.reply_text(
                "‚ùå Usage : `/confirmer <id_trajet>`\n\n"
                "Exemple : `/confirmer 123`",
                parse_mode='Markdown'
            )
            return
        
        try:
            trip_id = int(context.args[0])
        except ValueError:
            await update.message.reply_text(
                "‚ùå ID de trajet invalide. Veuillez saisir un nombre."
            )
            return
        
        try:
            with get_db_session() as session:
                # V√©rification que le trajet existe et appartient au conducteur
                trip = session.query(Trip).filter(
                    Trip.id == trip_id,
                    Trip.driver_id == user_id
                ).first()
                
                if not trip:
                    await update.message.reply_text(
                        f"‚ùå Trajet #{trip_id} non trouv√© ou vous n'√™tes pas le conducteur."
                    )
                    return
                
                # V√©rification que le trajet n'a pas d√©j√† √©t√© confirm√©
                if trip.status == 'completed':
                    await update.message.reply_text(
                        f"‚úÖ Le trajet #{trip_id} a d√©j√† √©t√© confirm√©."
                    )
                    return
                
                # R√©cup√©ration du conducteur
                driver = session.query(User).filter(User.telegram_id == user_id).first()
                if not driver:
                    await update.message.reply_text(
                        "‚ùå Conducteur non trouv√©."
                    )
                    return
                
                # V√©rification de l'email PayPal
                if not hasattr(driver, 'paypal_email') or not driver.paypal_email:
                    keyboard = [
                        [InlineKeyboardButton("üí≥ Configurer PayPal", callback_data="setup_paypal")],
                        [InlineKeyboardButton("‚ÑπÔ∏è Comment faire ?", callback_data="paypal_help")]
                    ]
                    
                    await update.message.reply_text(
                        "‚ö†Ô∏è *Email PayPal manquant*\n\n"
                        "Pour recevoir vos paiements automatiques, vous devez "
                        "d'abord configurer votre email PayPal.\n\n"
                        "üí° Utilisez la commande /paypal ou cliquez sur le bouton ci-dessous.",
                        parse_mode='Markdown',
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                    return
                
                # R√©cup√©ration des r√©servations pay√©es pour ce trajet
                paid_bookings = session.query(Booking).filter(
                    Booking.trip_id == trip_id,
                    Booking.payment_status == 'paid'
                ).all()
                
                if not paid_bookings:
                    await update.message.reply_text(
                        f"‚ùå Aucun passager n'a encore pay√© pour le trajet #{trip_id}."
                    )
                    return
                
                # Calcul du montant total √† verser au conducteur
                total_amount = sum(float(booking.total_price) for booking in paid_bookings)
                
                # Envoi du paiement au conducteur (88% du montant)
                success, payout_batch_id = pay_driver(
                    driver_email=driver.paypal_email,
                    trip_amount=total_amount
                )
                
                if success:
                    # Mise √† jour du statut du trajet
                    trip.status = 'completed'
                    trip.payout_batch_id = payout_batch_id
                    
                    # Mise √† jour des r√©servations
                    for booking in paid_bookings:
                        booking.status = 'completed'
                    
                    session.commit()
                    
                    driver_amount = round(total_amount * 0.88, 2)
                    commission = round(total_amount * 0.12, 2)
                    
                    await update.message.reply_text(
                        f"‚úÖ *Trajet #{trip_id} confirm√© !*\n\n"
                        f"üí∞ Montant total collect√© : {total_amount} CHF\n"
                        f"üíµ Votre part (88%) : {driver_amount} CHF\n"
                        f"üè¶ Commission (12%) : {commission} CHF\n\n"
                        f"üí≥ Le paiement a √©t√© envoy√© √† votre compte PayPal : {driver.paypal_email}\n\n"
                        f"Merci d'avoir utilis√© notre service de covoiturage ! üöó",
                        parse_mode='Markdown'
                    )
                    
                    # Notification aux passagers
                    for booking in paid_bookings:
                        passenger = session.query(User).filter(User.telegram_id == booking.passenger_id).first()
                        if passenger:
                            try:
                                await context.bot.send_message(
                                    chat_id=passenger.telegram_id,
                                    text=f"‚úÖ *Trajet termin√© !*\n\n"
                                         f"üöó Trajet #{trip_id} : {trip.departure_city} ‚Üí {trip.arrival_city}\n"
                                         f"üë§ Conducteur : {driver.full_name or 'Nom non d√©fini'}\n\n"
                                         f"Merci d'avoir voyag√© avec nous ! N'h√©sitez pas √† laisser un avis sur le conducteur.",
                                    parse_mode='Markdown'
                                )
                            except Exception as e:
                                logger.error(f"Erreur lors de l'envoi de notification au passager {passenger.telegram_id}: {e}")
                    
                    logger.info(f"Trajet {trip_id} confirm√©, paiement de {driver_amount} CHF envoy√© au conducteur")
                    
                else:
                    await update.message.reply_text(
                        "‚ùå Erreur lors de l'envoi du paiement PayPal. Veuillez contacter le support."
                    )
                    
        except Exception as e:
            logger.error(f"Erreur lors de la confirmation du trajet : {e}")
            await update.message.reply_text(
                "‚ùå Erreur lors de la confirmation du trajet. Veuillez r√©essayer plus tard."
            )
    
    @staticmethod
    async def payment_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Gestionnaire pour les callbacks de paiement
        """
        query = update.callback_query
        await query.answer()
        
        data = query.data
        user_id = update.effective_user.id
        
        if data.startswith("cancel_payment_"):
            trip_id = int(data.split("_")[2])
            
            try:
                with get_db_session() as session:
                    # Annulation du paiement en cours
                    booking = session.query(Booking).filter(
                        Booking.trip_id == trip_id,
                        Booking.passenger_id == user_id,
                        Booking.payment_status == 'pending'
                    ).first()
                    
                    if booking:
                        booking.payment_status = 'cancelled'
                        booking.paypal_payment_id = None
                        session.commit()
                
                await query.edit_message_text(
                    f"‚ùå Paiement du trajet #{trip_id} annul√©."
                )
                
            except Exception as e:
                logger.error(f"Erreur lors de l'annulation du paiement : {e}")
                await query.edit_message_text(
                    "‚ùå Erreur lors de l'annulation. Veuillez r√©essayer."
                )
    
    @staticmethod
    async def webhook_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Gestionnaire pour les webhooks PayPal
        Cette fonction serait appel√©e par un endpoint web s√©par√©
        """
        # Cette fonction serait normalement appel√©e par un serveur web
        # qui re√ßoit les webhooks PayPal
        pass
    
    @staticmethod
    async def check_payment_status_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Commande /statut_paiement - V√©rifier le statut des paiements
        """
        user_id = update.effective_user.id
        
        try:
            with get_db_session() as session:
                # R√©cup√©ration des r√©servations en cours de l'utilisateur
                bookings = session.query(Booking).filter(
                    Booking.passenger_id == user_id,
                    Booking.payment_status.in_(['pending', 'paid'])
                ).join(Trip).all()
                
                if not bookings:
                    await update.message.reply_text(
                        "‚ÑπÔ∏è Vous n'avez aucun paiement en cours."
                    )
                    return
                
                message = "üí≥ *Statut de vos paiements :*\n\n"
                
                for booking in bookings:
                    trip = booking.trip
                    status_emoji = "‚è≥" if booking.payment_status == 'pending' else "‚úÖ"
                    status_text = "En attente" if booking.payment_status == 'pending' else "Pay√©"
                    
                    message += (
                        f"{status_emoji} *Trajet #{trip.id}*\n"
                        f"üöó {trip.departure_city} ‚Üí {trip.arrival_city}\n"
                        f"üí∞ {format_swiss_price(booking.total_price)} CHF - {status_text}\n\n"
                    )
                
                await update.message.reply_text(message, parse_mode='Markdown')
                
        except Exception as e:
            logger.error(f"Erreur lors de la v√©rification du statut des paiements : {e}")
            await update.message.reply_text(
                "‚ùå Erreur lors de la v√©rification. Veuillez r√©essayer plus tard."
            )

    @staticmethod
    async def view_payments_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Callback pour voir les paiements de l'utilisateur
        """
        query = update.callback_query
        await query.answer()
        
        user_id = update.effective_user.id
        
        try:
            with get_db_session() as session:
                user = session.query(User).filter_by(telegram_id=user_id).first()
                if not user:
                    await query.edit_message_text("‚ùå Utilisateur non trouv√©.")
                    return
                
                # R√©cup√©rer les derniers paiements (tous statuts)
                bookings = session.query(Booking).filter_by(
                    passenger_id=user.id
                ).order_by(Booking.booking_date.desc()).limit(10).all()
                
                if not bookings:
                    message = "üí∞ *Mes paiements*\n\n" \
                             "Aucun paiement trouv√©.\n\n" \
                             "Vos paiements appara√Ætront ici une fois que vous aurez r√©serv√© des trajets."
                else:
                    message = "üí∞ *Mes paiements* (10 derniers)\n\n"
                    
                    for booking in bookings:
                        trip = booking.trip if booking.trip else None
                        if trip:
                            status_emoji = {
                                'pending': '‚è≥',
                                'completed': '‚úÖ',
                                'paid': '‚úÖ',
                                'unpaid': '‚ùå',
                                'cancelled': 'üö´'
                            }.get(booking.payment_status, '‚ùì')
                            
                            # Utiliser le bon champ pour le montant
                            amount = booking.total_price or booking.amount or 0
                            
                            message += f"{status_emoji} **{trip.departure_city} ‚Üí {trip.arrival_city}**\n"
                            message += f"üìÖ {trip.departure_time.strftime('%d/%m/%Y √† %H:%M')}\n"
                            message += f"üí∞ {format_swiss_price(amount)} CHF\n"
                            message += f"üìä Statut: {booking.payment_status.upper()}\n\n"
            
            keyboard = [
                [InlineKeyboardButton("üìä Voir tout l'historique", callback_data="payment_history")],
                [InlineKeyboardButton("üîÑ Actualiser", callback_data="view_payments")],
                [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
            ]
            
            await query.edit_message_text(
                message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown"
            )
            
        except Exception as e:
            logger.error(f"Erreur lors de l'affichage des paiements : {e}")
            # Message plus d√©taill√© pour d√©boguer
            await query.edit_message_text(
                f"‚ùå Erreur technique lors de l'affichage des paiements.\n\n"
                f"D√©tail de l'erreur: {str(e)}\n\n"
                f"Veuillez contacter le support si le probl√®me persiste."
            )

    @staticmethod
    async def payment_history_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Callback pour voir l'historique complet des paiements
        """
        query = update.callback_query
        await query.answer()
        
        user_id = update.effective_user.id
        
        try:
            with get_db_session() as session:
                user = session.query(User).filter_by(telegram_id=user_id).first()
                if not user:
                    await query.edit_message_text("‚ùå Utilisateur non trouv√©.")
                    return
                
                # R√©cup√©rer TOUS les paiements (comme passager)
                passenger_bookings = session.query(Booking).filter_by(
                    passenger_id=user.id
                ).order_by(Booking.booking_date.desc()).all()
                
                # R√©cup√©rer les trajets o√π l'utilisateur est conducteur et a re√ßu des paiements
                driver_trips = session.query(Trip).filter_by(
                    creator_id=user.id
                ).all()
                
                driver_bookings = []
                for trip in driver_trips:
                    bookings = session.query(Booking).filter_by(
                        trip_id=trip.id
                    ).filter(Booking.payment_status.in_(['completed', 'paid'])).all()
                    driver_bookings.extend(bookings)
                
                if not passenger_bookings and not driver_bookings:
                    message = "üìä *Historique complet*\n\n" \
                             "Aucun historique de paiement trouv√©.\n\n" \
                             "Votre historique appara√Ætra ici au fur et √† mesure de vos activit√©s."
                else:
                    message = "üìä *Historique complet des paiements*\n\n"
                    
                    # Statistiques rapides
                    total_spent = sum((b.total_price or b.amount or 0) for b in passenger_bookings if b.payment_status in ['completed', 'paid'])
                    total_earned = sum((b.total_price or b.amount or 0) for b in driver_bookings if b.payment_status in ['completed', 'paid'])
                    
                    message += f"üí∏ **Total d√©pens√©:** {format_swiss_price(total_spent)} CHF\n"
                    message += f"üí∞ **Total gagn√©:** {format_swiss_price(total_earned)} CHF\n"
                    message += f"üìà **Solde net:** {format_swiss_price(total_earned - total_spent)} CHF\n\n"
                    
                    # Paiements en tant que passager
                    if passenger_bookings:
                        message += "üë• **En tant que passager:**\n"
                        for booking in passenger_bookings[:5]:  # Limiter √† 5 pour √©viter un message trop long
                            trip = booking.trip if booking.trip else None
                            if trip:
                                status_emoji = {
                                    'pending': '‚è≥',
                                    'completed': '‚úÖ',
                                    'paid': '‚úÖ',
                                    'unpaid': '‚ùå',
                                    'cancelled': 'üö´'
                                }.get(booking.payment_status, '‚ùì')
                                
                                amount = booking.total_price or booking.amount or 0
                                message += f"{status_emoji} {trip.departure_city} ‚Üí {trip.arrival_city} - {format_swiss_price(amount)} CHF\n"
                        message += "\n"
                    
                    # Paiements re√ßus en tant que conducteur
                    if driver_bookings:
                        message += "üöó **En tant que conducteur:**\n"
                        for booking in driver_bookings[:5]:  # Limiter √† 5
                            trip = booking.trip if booking.trip else None
                            if trip:
                                amount = booking.total_price or booking.amount or 0
                                message += f"‚úÖ {trip.departure_city} ‚Üí {trip.arrival_city} - {format_swiss_price(amount)} CHF\n"
                        message += "\n"
                    
                    if len(passenger_bookings) > 5 or len(driver_bookings) > 5:
                        message += "üìù *Historique limit√© √† 5 entr√©es par cat√©gorie*"
            
            keyboard = [
                [InlineKeyboardButton("üí∞ Voir mes paiements", callback_data="view_payments")],
                [InlineKeyboardButton("üîÑ Actualiser", callback_data="payment_history")],
                [InlineKeyboardButton("üîô Retour", callback_data="menu:back_to_main")]
            ]
            
            await query.edit_message_text(
                message,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown"
            )
            
        except Exception as e:
            logger.error(f"Erreur lors de l'affichage de l'historique : {e}")
            # Message plus d√©taill√© pour d√©boguer
            await query.edit_message_text(
                f"‚ùå Erreur technique lors de l'affichage de l'historique.\n\n"
                f"D√©tail de l'erreur: {str(e)}\n\n"
                f"Veuillez contacter le support si le probl√®me persiste."
            )


# Cr√©ation du ConversationHandler pour la configuration PayPal
paypal_setup_conv_handler = ConversationHandler(
    entry_points=[CommandHandler('definirpaypal', PaymentHandlers.set_paypal_email_command)],
    states={
        WAITING_PAYPAL_EMAIL: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, PaymentHandlers.save_paypal_email),
            CommandHandler('cancel', PaymentHandlers.cancel_paypal_setup),
            CommandHandler('annuler', PaymentHandlers.cancel_paypal_setup),
        ],
    },
    fallbacks=[
        CommandHandler('cancel', PaymentHandlers.cancel_paypal_setup),
        CommandHandler('annuler', PaymentHandlers.cancel_paypal_setup),
    ],
    allow_reentry=True
)

# Gestionnaires de commandes
payment_command_handlers = [
    CommandHandler('payer', PaymentHandlers.pay_trip_command),
    CommandHandler('confirmer', PaymentHandlers.confirm_trip_command),
    CommandHandler('statut_paiement', PaymentHandlers.check_payment_status_command),
]

# Gestionnaire de callbacks
payment_callback_handler = CallbackQueryHandler(
    PaymentHandlers.payment_callback_handler,
    pattern=r'^(cancel_payment_|confirm_payment_)'
)

# Nouveaux gestionnaires pour les callbacks des paiements
view_payments_handler = CallbackQueryHandler(
    PaymentHandlers.view_payments_callback,
    pattern=r'^view_payments$'
)

payment_history_handler = CallbackQueryHandler(
    PaymentHandlers.payment_history_callback,
    pattern=r'^payment_history$'
)


def get_payment_handlers():
    """
    Retourne tous les gestionnaires de paiement √† ajouter √† l'application
    """
    return {
        'conversation_handlers': [paypal_setup_conv_handler],
        'command_handlers': payment_command_handlers,
        'callback_handlers': [payment_callback_handler, view_payments_handler, payment_history_handler]
    }


if __name__ == "__main__":
    print("‚úÖ Gestionnaires de paiement PayPal configur√©s")
    print("Commandes disponibles :")
    print("  /definirpaypal - Configurer l'email PayPal")
    print("  /payer <id_trajet> - Payer un trajet")
    print("  /confirmer <id_trajet> - Confirmer un trajet (conducteur)")
    print("  /statut_paiement - V√©rifier le statut des paiements")
