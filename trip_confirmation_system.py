#!/usr/bin/env python3
"""
Syst√®me de confirmation de trajet DOUBLE (conducteur + passager) pour lib√©rer le paiement
"""

import sys
import os
import importlib
sys.path.append('/Users/margaux/CovoiturageSuisse')

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext
from database.db_manager import get_db
from database.models import Booking, Trip, User
from datetime import datetime, timedelta

# Import avec rechargement forc√© pour s'assurer d'avoir la derni√®re version
import paypal_utils
importlib.reload(paypal_utils)
from paypal_utils import PayPalManager
import logging

logger = logging.getLogger(__name__)

async def add_confirmation_buttons_to_trip(trip_id: int, user_id: int, user_type: str):
    """
    Ajoute les boutons de confirmation √† un trajet si n√©cessaire
    
    Args:
        trip_id: ID du trajet
        user_id: ID de l'utilisateur (conducteur ou passager)
        user_type: 'driver' ou 'passenger'
    
    Returns:
        Liste de boutons √† ajouter
    """
    try:
        db = get_db()
        trip = db.query(Trip).filter(Trip.id == trip_id).first()
        
        if not trip:
            return []
        
        # V√©rifier s'il y a des r√©servations pay√©es pour ce trajet
        paid_bookings = db.query(Booking).filter(
            Booking.trip_id == trip_id,
            Booking.is_paid == True,
            Booking.status == 'confirmed'
        ).all()
        
        if not paid_bookings:
            return []  # Pas de paiements, pas de boutons
        
        now = datetime.now()
        
        # D√©terminer l'√©tat de confirmation actuel
        confirmation_state = get_trip_confirmation_state(trip_id, db)
        
        buttons = []
        
        if user_type == 'driver':
            # Boutons pour le conducteur
            if not confirmation_state['driver_confirmed']:
                if trip.departure_time > now:
                    # Trajet futur - bouton avec avertissement
                    days_until = (trip.departure_time - now).days
                    if days_until > 0:
                        button_text = f"‚ö†Ô∏è Confirmer trajet ({days_until}j avant)"
                    else:
                        button_text = "‚úÖ Confirmer trajet effectu√©"
                else:
                    # Trajet pass√© - bouton normal
                    button_text = "‚úÖ Confirmer trajet effectu√©"
                
                buttons.append(InlineKeyboardButton(
                    button_text, 
                    callback_data=f"confirm_trip_driver:{trip_id}"
                ))
            else:
                # Conducteur a d√©j√† confirm√©
                if confirmation_state['passenger_confirmed']:
                    buttons.append(InlineKeyboardButton(
                        "üéâ Trajet confirm√© (paiement lib√©r√©)", 
                        callback_data="noop"
                    ))
                else:
                    buttons.append(InlineKeyboardButton(
                        "‚è≥ En attente confirmation passager", 
                        callback_data="noop"
                    ))
        
        elif user_type == 'passenger':
            # Boutons pour le passager
            # V√©rifier que cet utilisateur a bien une r√©servation sur ce trajet
            user_booking = None
            for booking in paid_bookings:
                passenger = db.query(User).filter(User.id == booking.passenger_id).first()
                if passenger and passenger.telegram_id == user_id:
                    user_booking = booking
                    break
            
            if not user_booking:
                return []  # Cet utilisateur n'a pas de r√©servation pay√©e
            
            # V√©rifier l'√©tat de confirmation de ce passager sp√©cifique
            passenger_confirmations = confirmation_state.get('passenger_confirmations', {})
            passenger_confirmed = passenger_confirmations.get(str(user_booking.passenger_id), False)
            
            if not passenger_confirmed:
                if trip.departure_time > now:
                    # Trajet futur - bouton avec avertissement
                    days_until = (trip.departure_time - now).days
                    if days_until > 0:
                        button_text = f"‚ö†Ô∏è Confirmer trajet ({days_until}j avant)"
                    else:
                        button_text = "‚úÖ Confirmer trajet effectu√©"
                else:
                    # Trajet pass√© - bouton normal
                    button_text = "‚úÖ Confirmer trajet effectu√©"
                
                buttons.append(InlineKeyboardButton(
                    button_text, 
                    callback_data=f"confirm_trip_passenger:{trip_id}:{user_booking.id}"
                ))
            else:
                # Ce passager a d√©j√† confirm√©
                if confirmation_state['all_confirmed']:
                    buttons.append(InlineKeyboardButton(
                        "üéâ Trajet confirm√© (paiement lib√©r√©)", 
                        callback_data="noop"
                    ))
                else:
                    buttons.append(InlineKeyboardButton(
                        "‚è≥ En attente autres confirmations", 
                        callback_data="noop"
                    ))
        
        return buttons
        
    except Exception as e:
        logger.error(f"Erreur add_confirmation_buttons_to_trip: {e}")
        return []

def get_trip_confirmation_state(trip_id: int, db):
    """
    R√©cup√®re l'√©tat des confirmations pour un trajet
    
    Returns:
        dict avec driver_confirmed, passenger_confirmations, all_confirmed
    """
    try:
        trip = db.query(Trip).filter(Trip.id == trip_id).first()
        if not trip:
            return {'driver_confirmed': False, 'passenger_confirmations': {}, 'all_confirmed': False}
        
        # V√©rifier confirmation conducteur
        driver_confirmed = getattr(trip, 'driver_confirmed_completion', False)
        
        # V√©rifier confirmations passagers
        paid_bookings = db.query(Booking).filter(
            Booking.trip_id == trip_id,
            Booking.is_paid == True,
            Booking.status == 'confirmed'
        ).all()
        
        passenger_confirmations = {}
        all_passengers_confirmed = True
        
        for booking in paid_bookings:
            passenger_confirmed = getattr(booking, 'passenger_confirmed_completion', False)
            passenger_confirmations[str(booking.passenger_id)] = passenger_confirmed
            
            if not passenger_confirmed:
                all_passengers_confirmed = False
        
        # Toutes les confirmations re√ßues ?
        all_confirmed = driver_confirmed and all_passengers_confirmed and len(paid_bookings) > 0
        
        return {
            'driver_confirmed': driver_confirmed,
            'passenger_confirmations': passenger_confirmations,
            'passenger_confirmed': all_passengers_confirmed,  # Pour compatibilit√©
            'all_confirmed': all_confirmed
        }
        
    except Exception as e:
        logger.error(f"Erreur get_trip_confirmation_state: {e}")
        return {'driver_confirmed': False, 'passenger_confirmations': {}, 'all_confirmed': False}

async def handle_trip_confirmation_callback(update: Update, context: CallbackContext):
    """
    G√®re les callbacks de confirmation de trajet (double confirmation)
    """
    try:
        query = update.callback_query
        await query.answer()
        
        data = query.data
        parts = data.split(':')
        action = parts[0]
        trip_id = int(parts[1])
        
        db = get_db()
        trip = db.query(Trip).filter(Trip.id == trip_id).first()
        
        if not trip:
            await query.edit_message_text("‚ùå Trajet non trouv√©.")
            return
        
        now = datetime.now()
        
        if action == "confirm_trip_driver":
            await handle_driver_confirmation(query, trip, db, now)
            
        elif action == "confirm_trip_passenger":
            booking_id = int(parts[2]) if len(parts) > 2 else None
            await handle_passenger_confirmation(query, trip, booking_id, db, now)
        
        elif action == "force_confirm_driver":
            # Confirmation forc√©e du conducteur apr√®s double v√©rification
            await confirm_driver_completion(query, trip, db, context)
            
        elif action == "force_confirm_passenger":
            # Confirmation forc√©e du passager apr√®s double v√©rification
            booking_id = int(parts[2]) if len(parts) > 2 else None
            booking = db.query(Booking).filter(Booking.id == booking_id).first()
            if booking:
                await confirm_passenger_completion(query, trip, booking, db, context)
            else:
                await query.edit_message_text("‚ùå R√©servation non trouv√©e.")
            
    except Exception as e:
        logger.error(f"Erreur handle_trip_confirmation_callback: {e}")
        await query.edit_message_text("‚ùå Erreur lors de la confirmation.")

async def handle_driver_confirmation(query, trip: Trip, db, now: datetime):
    """G√®re la confirmation du conducteur"""
    try:
        # TOUJOURS demander une double confirmation (m√™me pour trajets pass√©s)
        trip_status = "pass√©" if trip.departure_time <= now else "√† venir"
        days_text = ""
        
        if trip.departure_time > now:
            days_until = (trip.departure_time - now).days
            if days_until > 0:
                days_text = f"Le trajet a lieu dans {days_until} jour(s).\n"
            else:
                hours_until = (trip.departure_time - now).total_seconds() / 3600
                days_text = f"Le trajet a lieu dans {hours_until:.1f} heure(s).\n"
        else:
            # Trajet pass√©
            days_ago = (now - trip.departure_time).days
            if days_ago == 0:
                days_text = "Le trajet √©tait pr√©vu aujourd'hui.\n"
            else:
                days_text = f"Le trajet √©tait pr√©vu il y a {days_ago} jour(s).\n"
        
        # Demander confirmation avec d√©tails complets
        keyboard = [
            [InlineKeyboardButton("‚úÖ Oui, confirmer le trajet", callback_data=f"force_confirm_driver:{trip.id}")],
            [InlineKeyboardButton("‚ùå Non, annuler", callback_data="noop")]
        ]
        
        await query.edit_message_text(
            f"‚ö†Ô∏è **CONFIRMATION IMPORTANTE**\n\n"
            f"üìç **Trajet :** {trip.departure_city} ‚Üí {trip.arrival_city}\n"
            f"üìÖ **Date :** {trip.departure_time.strftime('%d/%m/%Y √† %H:%M')}\n"
            f"üïê **Statut :** {days_text}\n"
            f"üí∞ **Impact :** Cette confirmation peut d√©clencher votre paiement\n\n"
            f"‚ùì **Confirmez-vous que ce trajet s'est bien d√©roul√© ?**\n"
            f"‚ö†Ô∏è Cette action est d√©finitive !",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erreur handle_driver_confirmation: {e}")

async def handle_passenger_confirmation(query, trip: Trip, booking_id: int, db, now: datetime):
    """G√®re la confirmation d'un passager"""
    try:
        booking = db.query(Booking).filter(Booking.id == booking_id).first()
        if not booking:
            await query.edit_message_text("‚ùå R√©servation non trouv√©e.")
            return
        
        # TOUJOURS demander une double confirmation (m√™me pour trajets pass√©s)
        trip_status = "pass√©" if trip.departure_time <= now else "√† venir"
        days_text = ""
        
        if trip.departure_time > now:
            days_until = (trip.departure_time - now).days
            if days_until > 0:
                days_text = f"Le trajet a lieu dans {days_until} jour(s).\n"
            else:
                hours_until = (trip.departure_time - now).total_seconds() / 3600
                days_text = f"Le trajet a lieu dans {hours_until:.1f} heure(s).\n"
        else:
            # Trajet pass√©
            days_ago = (now - trip.departure_time).days
            if days_ago == 0:
                days_text = "Le trajet √©tait pr√©vu aujourd'hui.\n"
            else:
                days_text = f"Le trajet √©tait pr√©vu il y a {days_ago} jour(s).\n"
        
        # Demander confirmation avec d√©tails complets
        keyboard = [
            [InlineKeyboardButton("‚úÖ Oui, confirmer le trajet", callback_data=f"force_confirm_passenger:{trip.id}:{booking_id}")],
            [InlineKeyboardButton("‚ùå Non, annuler", callback_data="noop")]
        ]
        
        await query.edit_message_text(
            f"‚ö†Ô∏è **CONFIRMATION IMPORTANTE**\n\n"
            f"üìç **Trajet :** {trip.departure_city} ‚Üí {trip.arrival_city}\n"
            f"üìÖ **Date :** {trip.departure_time.strftime('%d/%m/%Y √† %H:%M')}\n"
            f"üïê **Statut :** {days_text}\n"
            f"üí∞ **Impact :** Cette confirmation d√©clenchera le paiement du conducteur\n\n"
            f"‚ùì **Confirmez-vous que ce trajet s'est bien d√©roul√© ?**\n"
            f"‚ö†Ô∏è Cette action est d√©finitive !",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erreur handle_passenger_confirmation: {e}")

async def confirm_driver_completion(query, trip: Trip, db, context: CallbackContext):
    """Confirme la completion c√¥t√© conducteur"""
    try:
        # Marquer la confirmation conducteur
        trip.driver_confirmed_completion = True
        db.commit()
        
        # V√©rifier si toutes les confirmations sont re√ßues
        confirmation_state = get_trip_confirmation_state(trip.id, db)
        
        if confirmation_state['all_confirmed']:
            # Toutes les confirmations re√ßues - lib√©rer le paiement
            await release_payment_to_driver(query, trip, db, context)
        else:
            # En attente des confirmations passagers
            await query.edit_message_text(
                f"‚úÖ **Votre confirmation enregistr√©e !**\n\n"
                f"üìç {trip.departure_city} ‚Üí {trip.arrival_city}\n"
                f"üìÖ {trip.departure_time.strftime('%d/%m/%Y √† %H:%M')}\n\n"
                f"‚è≥ **En attente des confirmations des passagers.**\n"
                f"Le paiement sera lib√©r√© une fois que tous les passagers auront confirm√©.",
                parse_mode='Markdown'
            )
        
        logger.info(f"‚úÖ Conducteur a confirm√© le trajet {trip.id}")
        
    except Exception as e:
        logger.error(f"Erreur confirm_driver_completion: {e}")

async def confirm_passenger_completion(query, trip: Trip, booking: Booking, db, context: CallbackContext):
    """Confirme la completion c√¥t√© passager"""
    try:
        # Marquer la confirmation passager
        booking.passenger_confirmed_completion = True
        db.commit()
        
        # V√©rifier si toutes les confirmations sont re√ßues
        confirmation_state = get_trip_confirmation_state(trip.id, db)
        
        if confirmation_state['all_confirmed']:
            # Toutes les confirmations re√ßues - lib√©rer le paiement
            await release_payment_to_driver(query, trip, db, context)
        else:
            # En attente d'autres confirmations
            await query.edit_message_text(
                f"‚úÖ **Votre confirmation enregistr√©e !**\n\n"
                f"üìç {trip.departure_city} ‚Üí {trip.arrival_city}\n"
                f"üìÖ {trip.departure_time.strftime('%d/%m/%Y √† %H:%M')}\n\n"
                f"‚è≥ **En attente d'autres confirmations.**\n"
                f"Le paiement du conducteur sera lib√©r√© une fois que toutes les parties auront confirm√©.",
                parse_mode='Markdown'
            )
        
        logger.info(f"‚úÖ Passager {booking.passenger_id} a confirm√© le trajet {trip.id}")
        
    except Exception as e:
        logger.error(f"Erreur confirm_passenger_completion: {e}")

async def release_payment_to_driver(query, trip: Trip, db, context: CallbackContext):
    """Lib√®re le paiement au conducteur apr√®s double confirmation"""
    try:
        logger.info(f"üöÄ D√âBUT release_payment_to_driver pour trip {trip.id}")
        
        # Marquer le trajet comme compl√®tement confirm√©
        trip.status = 'completed_confirmed'
        trip.payment_released = True
        logger.info(f"‚úÖ Trip {trip.id} marqu√© comme completed_confirmed et payment_released=True")
        db.commit()
        
        # Calculer le montant √† lib√©rer
        logger.info(f"üîç Recherche des r√©servations pay√©es pour trip {trip.id}")
        paid_bookings = db.query(Booking).filter(
            Booking.trip_id == trip.id,
            Booking.is_paid == True
        ).all()
        
        logger.info(f"üìã {len(paid_bookings)} r√©servations pay√©es trouv√©es")
        
        total_amount = sum(booking.amount for booking in paid_bookings if booking.amount)
        driver_amount = total_amount * 0.88  # 88% pour le conducteur
        
        logger.info(f"üí∞ Calcul montants: total={total_amount} CHF, conducteur={driver_amount} CHF")
        
        # Marquer les r√©servations comme termin√©es
        logger.info(f"üîÑ Marquage des {len(paid_bookings)} r√©servations comme completed_confirmed")
        for booking in paid_bookings:
            booking.status = 'completed_confirmed'
        db.commit()
        logger.info(f"‚úÖ R√©servations mises √† jour")
        
        # Message de confirmation
        message = (
            f"üéâ **PAIEMENT LIB√âR√â !**\n\n"
            f"üìç {trip.departure_city} ‚Üí {trip.arrival_city}\n"
            f"üìÖ {trip.departure_time.strftime('%d/%m/%Y √† %H:%M')}\n"
            f"üí∞ **Montant : {driver_amount:.2f} CHF**\n\n"
            f"‚úÖ Toutes les confirmations re√ßues !\n"
            f"üè¶ Votre paiement sera trait√© dans les prochaines 24h.\n\n"
            f"Merci d'utiliser CovoiturageSuisse !"
        )
        
        logger.info(f"üì± Envoi du message de confirmation √† l'utilisateur")
        await query.edit_message_text(message, parse_mode='Markdown')
        
        # Notifier le conducteur
        logger.info(f"üîî Notification du conducteur (trip.driver_id={trip.driver_id})")
        try:
            await context.bot.send_message(
                chat_id=trip.driver_id,
                text=message,
                parse_mode='Markdown'
            )
            logger.info(f"‚úÖ Conducteur notifi√© avec succ√®s")
        except Exception as e:
            logger.error(f"‚ùå Erreur notification conducteur: {e}")
        
        # Notifier tous les passagers
        logger.info(f"üîî Notification des {len(paid_bookings)} passagers")
        for booking in paid_bookings:
            try:
                passenger = db.query(User).filter(User.id == booking.passenger_id).first()
                if passenger and passenger.telegram_id:
                    await context.bot.send_message(
                        chat_id=passenger.telegram_id,
                        text=f"üéâ **Trajet confirm√© !**\n\n"
                             f"üìç {trip.departure_city} ‚Üí {trip.arrival_city}\n"
                             f"üìÖ {trip.departure_time.strftime('%d/%m/%Y')}\n\n"
                             f"‚úÖ Le conducteur a √©t√© pay√© suite √† vos confirmations mutuelles.\n"
                             f"Merci d'avoir utilis√© CovoiturageSuisse !",
                        parse_mode='Markdown'
                    )
                    logger.info(f"‚úÖ Passager {booking.passenger_id} notifi√©")
            except Exception as e:
                logger.error(f"‚ùå Erreur notification passager {booking.passenger_id}: {e}")
        
        logger.info(f"üéâ Paiement de {driver_amount:.2f} CHF lib√©r√© pour trajet {trip.id}")
        
        # üöÄ NOUVEAU: D√©clencher le vrai paiement au conducteur
        logger.info(f"üöÄ APPEL process_driver_payout pour {driver_amount:.2f} CHF")
        await process_driver_payout(trip, driver_amount, db, context)
        logger.info(f"‚úÖ process_driver_payout termin√©")
        
    except Exception as e:
        logger.error(f"‚ùå ERREUR CRITIQUE dans release_payment_to_driver: {e}")
        import traceback
        logger.error(f"üìö Stack trace: {traceback.format_exc()}")

async def process_driver_payout(trip: Trip, driver_amount: float, db, context: CallbackContext):
    """
    Traite le paiement automatique au conducteur via PayPal
    """
    try:
        logger.info(f"üöÄ D√âBUT process_driver_payout: trip {trip.id}, montant {driver_amount:.2f} CHF")
        
        # R√©cup√©rer les infos du conducteur
        logger.info(f"üîç Recherche du conducteur ID {trip.driver_id}")
        driver = db.query(User).filter(User.id == trip.driver_id).first()
        
        if not driver:
            logger.error(f"‚ùå Conducteur non trouv√© pour trip {trip.id}")
            trip.status = 'payment_failed'
            db.commit()
            return
            
        logger.info(f"‚úÖ Conducteur trouv√©: ID={driver.id}, telegram_id={driver.telegram_id}")
        
        if not driver.paypal_email:
            logger.error(f"‚ùå Conducteur {driver.id} n'a pas d'email PayPal configur√©")
            # Marquer qu'il faut un paiement manuel
            trip.status = 'payment_pending_manual'
            db.commit()
            return
        
        logger.info(f"‚úÖ Email PayPal conducteur: {driver.paypal_email}")
        
        # Initialiser PayPal
        logger.info(f"üîå Initialisation PayPal...")
        paypal = PayPalManager()
        logger.info(f"‚úÖ PayPal initialis√©")
        
        # üîç DIAGNOSTIC: V√©rifier les m√©thodes disponibles
        logger.info(f"üîç M√©thodes disponibles dans PayPalManager: {[method for method in dir(paypal) if not method.startswith('_')]}")
        
        # Description du trajet pour PayPal
        trip_description = f"{trip.departure_city} ‚Üí {trip.arrival_city} ({trip.departure_time.strftime('%d/%m/%Y')})"
        
        # üí∞ EFFECTUER LE PAIEMENT R√âEL
        logger.info(f"üè¶ TENTATIVE PAIEMENT PAYPAL:")
        logger.info(f"   ‚Üí Montant: {driver_amount:.2f} CHF")
        logger.info(f"   ‚Üí Destinataire: {driver.paypal_email}")
        logger.info(f"   ‚Üí Description: {trip_description}")
        
        # V√©rifier si la m√©thode existe avant de l'appeler
        if hasattr(paypal, 'payout_to_driver'):
            logger.info(f"‚úÖ M√©thode payout_to_driver trouv√©e")
            success, payout_details = paypal.payout_to_driver(
                driver_email=driver.paypal_email,
                amount=driver_amount,
                trip_description=trip_description
            )
        else:
            logger.error(f"‚ùå M√©thode payout_to_driver NOT FOUND dans PayPalManager")
            logger.error(f"üìö M√©thodes disponibles: {dir(paypal)}")
            success = False
            payout_details = None
        
        logger.info(f"üìä R√©sultat paiement PayPal: success={success}")
        if payout_details:
            logger.info(f"üìã D√©tails payout: {payout_details}")
        
        if success and payout_details:
            # ‚úÖ PAIEMENT R√âUSSI
            logger.info(f"üéâ PAIEMENT PAYPAL R√âUSSI!")
            batch_id = payout_details.get('batch_id')
            trip.payout_batch_id = batch_id
            trip.status = 'completed_paid'
            trip.driver_amount = driver_amount
            trip.commission_amount = sum(booking.amount for booking in db.query(Booking).filter(
                Booking.trip_id == trip.id,
                Booking.is_paid == True
            ).all()) * 0.12
            
            db.commit()
            
            logger.info(f"‚úÖ Base de donn√©es mise √† jour avec batch_id: {batch_id}")
            
            # Notifier le conducteur du paiement r√©ussi
            try:
                await context.bot.send_message(
                    chat_id=driver.telegram_id,
                    text=f"üí∞ **PAIEMENT ENVOY√â !**\n\n"
                         f"üìß PayPal: {driver.paypal_email}\n"
                         f"üíµ Montant: {driver_amount:.2f} CHF\n"
                         f"üöó Trajet: {trip_description}\n\n"
                         f"‚úÖ Le paiement arrivera dans votre compte PayPal dans les prochaines minutes.\n\n"
                         f"Merci d'utiliser CovoiturageSuisse !",
                    parse_mode='Markdown'
                )
                logger.info(f"‚úÖ Notification paiement r√©ussi envoy√©e au conducteur")
            except Exception as e:
                logger.error(f"‚ùå Erreur notification conducteur paiement: {e}")
                
        else:
            # ‚ùå √âCHEC DU PAIEMENT
            logger.error(f"‚ùå √âCHEC PAIEMENT PAYPAL pour trajet {trip.id}")
            trip.status = 'payment_failed'
            db.commit()
            
            # Notifier l'√©chec
            try:
                await context.bot.send_message(
                    chat_id=driver.telegram_id,
                    text=f"‚ö†Ô∏è **Probl√®me avec votre paiement**\n\n"
                         f"üí∞ Montant: {driver_amount:.2f} CHF\n"
                         f"üöó Trajet: {trip_description}\n\n"
                         f"‚ùå Le paiement automatique a √©chou√©.\n"
                         f"üìß V√©rifiez votre email PayPal: {driver.paypal_email}\n\n"
                         f"Notre √©quipe va traiter le paiement manuellement dans les 24h.",
                    parse_mode='Markdown'
                )
                logger.info(f"‚úÖ Notification √©chec paiement envoy√©e au conducteur")
            except Exception as e:
                logger.error(f"‚ùå Erreur notification √©chec paiement: {e}")
                
    except Exception as e:
        logger.error(f"‚ùå ERREUR CRITIQUE dans process_driver_payout: {e}")
        import traceback
        logger.error(f"üìö Stack trace payout: {traceback.format_exc()}")
        # Marquer pour traitement manuel
        trip.status = 'payment_error'
        db.commit()
